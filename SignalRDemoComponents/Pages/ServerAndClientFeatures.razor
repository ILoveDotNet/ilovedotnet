@page "/blogs/server-and-client-features"
@inherits FragmentNavigationBase
@inject TableOfContents tableOfContents

<Content Description=@Description
         Slug=@Slug
         PosterPath=@PosterPath
         Channel="@Channel"
         ContentType="@ContentType"
         TotalContents=@TotalContents
         Type="SignalR"
         FileName=@nameof(ServerAndClientFeatures)>
    <ContentBody>
        <p>
            In this article, let's learn about fundamentals of <ContentHighlight>SignalR</ContentHighlight> in <ContentHighlight>dotnet</ContentHighlight>.
        </p>

        <h3 class="[ font-semibold text-lg ]">Table of Contents</h3>

        <ol class="[ list-decimal ] [ ml-4 ]">
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#introduction")" Match="NavLinkMatch.All">
                    Introduction
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#more-clients")" Match="NavLinkMatch.All">
                    More Clients
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#i-hubcontext-and-caller")" Match="NavLinkMatch.All">
                    IHubContext and Caller
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#groups-and-connection-id")" Match="NavLinkMatch.All">
                    Groups and ConnectionId
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#message-pack-hub-protocol-and-keep-alive")" Match="NavLinkMatch.All">
                    Message Pack Hub Protocol and Keep Alive
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#exceptions-and-logging")" Match="NavLinkMatch.All">
                    Exceptions and Logging
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#streaming")" Match="NavLinkMatch.All">
                    Streaming
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#authentication-and-authorization")" Match="NavLinkMatch.All">
                    Authentication & Authorization
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#design-considerations")" Match="NavLinkMatch.All">
                    Design Considerations
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#deploying")" Match="NavLinkMatch.All">
                    Deploying
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#scaling")" Match="NavLinkMatch.All">
                    Scaling
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#summary")" Match="NavLinkMatch.All">
                    Summary
                </NavLink>
            </li>
        </ol>

        <h3 id="introduction" class="[ font-semibold text-lg ]">Introduction</h3>

        <p>
            In our previous article we learnt the fundamentals of SignalR. Today in this article lets dive deep into the server and client features available in 
            SignalR in .NET. All these are essential to build a real-time applications.
        </p>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="more-clients" class="[ font-semibold text-lg ]">More Clients</h3>

        <p>
            SignalR isn't just for browsers. Your clients can be all sorts of applications - desktop, web, or mobile, and they don't even have to match. Mix 
            and match to your heart's content!
        </p>

        <p>
            Plus, you're not limited to any specific tech stack. Whether it's React, Angular, WPF, .NET MAUI, or Blazor, they can all hop on the SignalR train. 
            The only thing to watch for is having the right client libraries. Luckily, there are JavaScript, .NET, and Java libraries available, so as long as 
            your app's using one of those, you're good to go.
        </p>

        <p>
            In previous post, we saw an example of web client. Now, we will see how to create a console client.
        </p>

        <ol class="[ list-decimal ] [ ml-4 ]">
            <li>Add <ContentHighlight CssClasses="[ break-all ]">Microsoft.AspNetCore.SignalR.Client</ContentHighlight> Nuget Package to Client</li>
            <li>Create <ContentHighlight>HubConnection</ContentHighlight></li>
            <li>Configure <ContentHighlight>Handler</ContentHighlight> to be invoked</li>
            <li><ContentHighlight>Start</ContentHighlight> the HubConnection</li>
            <li>Finally close it on Component <ContentHighlight>Dispose</ContentHighlight></li>
        </ol>

        <GithubGistSnippet Title="Creating and Configuring Console Client" UserId="fingers10" FileName="f5426199e3f4924095b92e236854dbfc"></GithubGistSnippet>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="i-hubcontext-and-caller" class="[ font-semibold text-lg ]">IHubContext and Caller</h3>

        <p>
            The IHubContext interface, which is tailored to each hub, can be injected and then used to access the hub's client property. It's super handy to 
            have IHubContext available in dependency injection because it means we can tap into it from anywhere in the app where the Hub class is hanging out. 
            But there's a catch: The caller is only accessible within the hub itself, not through IHubContext.
        </p>

        <GithubGistSnippet Title="IHubContext and Caller" UserId="fingers10" FileName="6004fe10717dcb27a02eace5b5fc8f70"></GithubGistSnippet>

        <p>
            This leaves us with no possibility to send any notifications to the Caller alone. But there's also the possibility to put clients in groups and then 
            send messages to a specific group.
        </p>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="groups-and-connection-id" class="[ font-semibold text-lg ]">Groups and ConnectionId</h3>

        <p>
            Client groups are like superchargers in SignalR. You can organize clients into groups using their connection ID. When a client first connects to the 
            hub or calls a hub method, it gets assigned a unique connection ID. This ID sticks around as long as the connection stays alive. Just a heads up 
            though, if a new connection happens, like from a network hiccup or a page refresh (you know, hitting F5 in the browser), the connection ID changes.
        </p>

        <p>
            But let's get back to the good stuff - groups. They're dynamic and live right in the server's memory. No need to set them up or save them anywhere. 
            Once you add a connection ID to a group, boom, the group exists. And once you've got a group, you can use the Clients property in the hub to talk to 
            all the clients in that group. How cool is that?
        </p>

        <GithubGistSnippet Title="Groups and ConnectionId" UserId="fingers10" FileName="0903bc8ebe466f34f791082cd9591aa0"></GithubGistSnippet>

        <p>
            When a call comes in, we first figure out a name for the group it belongs to. Then, we add the connection ID of the client making the call to that 
            group. The Hub base class has this handy property called Context that gives us info about the connection, like the connection ID. But there's more 
            to come on that.
        </p>

        <p>
            If the group doesn't exist yet, no sweat. It'll be created when we add that connection ID to it. And if the connection ID was already in the group? 
            No biggie. Adding it again doesn't change a thing. That's the beauty of groups being so dynamic.
        </p>

        <p>
            Now, here's the fun part: We can call a function on every client in the group, except the one making the call. How? By using the OthersInGroup method 
            on the Clients property, we specify the group name and then call SendAsync.
        </p>

        <p>
            The Clients property has some extra tricks up its sleeve. For instance, we can send messages to a whole group, including the caller, or leave out 
            specific connection IDs. And if we need to target a specific connection ID or a list of them, we can use the Client and Clients methods. So many 
            options to play around with!
        </p>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="message-pack-hub-protocol-and-keep-alive" class="[ font-semibold text-lg ]">Message Pack Hub Protocol and Keep Alive</h3>

        <p>
            We covered hub protocol in the previous module, and we saw that by default a JSON protocol was used. Assuming the WebSocket's transport is used, 
            you can actually see the JSON messages when going to the Network tab of the F12 tools of your browser. When you click on the WebSocket connection 
            to the hub and select the Messages tab, you can see the message going through. When you click on it, you can see the actual message.
        </p>

        <p>
            There are also a number of other messages visible, which are of type:6. These are keepalive messages. They are needed because WebSocket connections 
            tend to close automatically after a certain period of inactivity, and the keepalive messages are preventing that. Since JSON is text, it is not very 
            efficient, especially when dealing with larger messages. When you, for example, work with larger objects that are passed as parameters, JSON protocol 
            might be too slow or too inefficient. In that case, there's the option to switch to MessagePack hub protocol, which is binary.
        </p>

        <p>
            To enable MessagePack Protocol install the Nuget package Microsoft.AspNetCore.SignalR.Protocols.MessagePack and do the following setup.
        </p>

        <GithubGistSnippet Title="MessagePack Protocol" UserId="fingers10" FileName="d5939dd731bcc3cf9dc57170c5b736d5"></GithubGistSnippet>

        <p>
            MessagePack serialization is strictly case-sensitive. That means that the property names of the objects that are sent through the connection should 
            match exactly. So to make this work, we have to use Pascal casing for property names.  It's a MessagePack quirk that is not easy to bypass. When we 
            now run the application and look at the messages again, they are now binary. That's an advantage in terms of performance, but it also has a downside. 
            They are not as easy to read as the JSON messages.
        </p>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="exceptions-and-logging" class="[ font-semibold text-lg ]">Exceptions and Logging</h3>

        <p>
            What happens when a hub method is invoked and an exception occurs?  So when an exception occurs on the server, the connection will not close. The 
            only thing the hub do is sent a message to the client that something went wrong. The client library detected that and throw the error.
        </p>

        <GithubGistSnippet Title="Standard Exception" UserId="fingers10" FileName="a1cbd2e4591cd688756bb13658e93cc2"></GithubGistSnippet>

        <p>
            And to see the exception message, there are two possible solutions. Instead of throwing a standard exception, you could throw a 
            HubException. Now, the message is visible. This is usable when you deliberately want to send an exception message to the client, for example, 
            a data validation error. SignalR will also throw HubExceptions itself when something goes wrong.
        </p>

        <GithubGistSnippet Title="Hub Exception" UserId="fingers10" FileName="048e09567ccde6d07a9eeba0531907cf"></GithubGistSnippet>

        <p>
            All exceptions that are not HubExceptions thrown on the server will not contain the exception message. But if you always want that message, no matter 
            which exception is thrown, in Program.cs where SignalR is added to DI.  Note that just the Exception message is sent to the client, not the stack 
            trace or other exception information. You should be careful turning on EnabledDetailedErrors because this information could also reveal possible 
            attack vectors to your application. Therefore, I recommend not turning this on in production.
        </p>

        <GithubGistSnippet Title="SignalR Exception Configuration" UserId="fingers10" FileName="3020358cc3c01c9312043e369ce176cc"></GithubGistSnippet>

        <p>
            To see more logs, Microsoft.AspNetCore.SignalR category is about all activity of hubs like invoking methods. You can also set 
            Microsoft.AspNetCore.Http.Connections to get logging around transports such as which transport was selected and activity around the selected 
            transport
        </p>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>
        
        <h3 id="streaming" class="[ font-semibold text-lg ]">Streaming</h3>

        <p>
            Streaming with SignalR is pretty specialized. If we're talking about using WebSockets for connections, the messages flying back and forth don't weigh 
            much in terms of overhead. Since the connection's already set up, the biggest chunk of overhead is likely in serializing and deserializing, which 
            happens pretty quickly. So if you're passing things like real time data, the regular SignalR transport should do the trick just fine.
        </p>

        <p>
            But streaming isn't the best fit for everything, especially not for binary data like audio and video. SignalR uses a JSON-based transport, even if 
            it's using MessagePack, which means JSON gets turned into binary. So, not the smoothest ride for audio and video.
        </p>

        <GithubGistSnippet Title="SignalR Streaming" UserId="fingers10" FileName="e1f3ba4262e6fc779816c9a98c5ea75b"></GithubGistSnippet>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="authentication-and-authorization" class="[ font-semibold text-lg ]">Authentication & Authorization</h3>

        <p>
            The cool thing is that the SignalR hub can make use of everything that's in ASP.NET Core already. We can just put the Authorize attribute above 
            ILoveDotNetHub and now users that don't have a valid credentials can't access it. SignalR supports both JWT and Cookie authentication. Here is the 
            example for JWT authentication.
        </p>

        <GithubGistSnippet Title="SignalR Authentication and Authorization" UserId="fingers10" FileName="94e766fdabbe112709b2ce6198c1f798"></GithubGistSnippet>

        <p>
            Authorization doesn't work any differently with SignalR than it does with any other ASP.NET Core application. You can use Context.User.Claims and 
            get the claims and work on them.
        </p>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="design-considerations" class="[ font-semibold text-lg ]">Design Considerations</h3>

        <p>
            SignalR can be a game-changer if you can use it, but it's best not to rely on it for your app's main functions if you can help it. See, connecting 
            to the hub isn't as dependable or secure as traditional request-response setups. That's why I suggest teaming up SignalR with a tried-and-true API, 
            like REST or gRPC, for your heavy lifting. Let the hub handle notifications and keep the critical stuff, like data handling, to the reliable APIs.
        </p>

        <p>
            Imagine what happens if the SignalR connection suddenly drops. It's more common than you might realize. One way to handle this is by telling the 
            client to reconnect automatically. By doing this, it'll keep trying to connect, with longer intervals between attempts. But remember, each 
            reconnection means a new connection ID, so it won't be part of any groups anymore.
        </p>

        <p>
            Also, the connection object has two handy events: onreconnecting, which tells you why the disconnect happened, and onreconnected, which gives you 
            the new connection ID. With these events, you can keep the user informed or adjust the app's state as needed.
        </p>

        <GithubGistSnippet Title="SignalR Automatic Reconnect" UserId="fingers10" FileName="5f6f1b982119bec653fa4d2ff174c143"></GithubGistSnippet>

        <p>
            Here's a cool feature introduced in ASP.NET Core 8 called Stateful Reconnect. When it's turned on and the connection takes a dive, any messages 
            that were supposed to go between server and client get stored in a buffer, just hanging out in memory. And get this - there can be buffers on both 
            sides, client and server. Once the connection gets back on its feet, those buffered messages get delivered. Better late than never, huh? Just so you 
            know, there's a limit to how big the buffer can get on each side - it's set to 100 KB by default.
        </p>

        <GithubGistSnippet Title="SignalR Stateful Reconnect" UserId="fingers10" FileName="251389e6a2221fc48d93b849d4243c64"></GithubGistSnippet>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="deploying" class="[ font-semibold text-lg ]">Deploying</h3>

        <p>
            Once your app is out there, whether it's chilling in the cloud or hanging out on local servers, double-check that WebSockets are switched on. 
            Sometimes, they're turned off by default, so keep an eye out for that.
        </p>

        <p>
            Also, watch out for connection limits. There's usually a cap on how many WebSocket connections can happen simultaneously. And if you're using other 
            methods besides WebSockets, there might be limits on HTTP requests too.
        </p>

        <p>
            Oh, and don't forget about sticky sessions (or ARR Affinity if you're feeling fancy). You'll want those turned on when you're scaling out your app, 
            meaning you've got it running on multiple servers to handle lots of requests at once. Keep those sessions sticky for a smooth ride!
        </p>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="scaling" class="[ font-semibold text-lg ]">Scaling</h3>

        <p>
            When your app is up and running in the cloud, making it handle more traffic is usually as easy as adjusting a slider to add more instances. There's 
            this thing called a load balancer that helps out by picking a server for each new request that comes in. It might choose servers one after the other, 
            or use some other smart way to decide.
        </p>

        <p>
            If you're just using WebSocket, you're all good. Once that connection is set up, it's like there's a direct tunnel between one server and the browser, 
            so no worries there.
        </p>

        <p>
            But if you're using other methods to send messages, things get tricky without sticky sessions. See, each message is treated like a separate request. 
            So, every time a message is sent, it might land on a different server. And that server might not have a clue about what messages were sent earlier 
            or what's going on.
        </p>

        <p>
            Sticky sessions come to the rescue! There are a bunch of ways to make this work, but here's the gist: When the first request is sent, the load 
            balancer tags the browser with a cookie, showing which server it used. Then, for future requests, the load balancer checks that cookie and sends 
            them to the same server as before.
        </p>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="summary" class="[ font-semibold text-lg ]">Summary</h3>

        <p>
            In this article, we learn about the server and client features available in SignalR in .NET. We saw how to create a console client, use IHubContext 
            and Caller, work with groups and connection ID, switch to MessagePack hub protocol, handle exceptions and logging, stream data, authenticate and 
            authorize users, and design considerations. We also saw how to automatically reconnect and use stateful reconnect. We closed with deploying and 
            scaling considerations. In next article, we will see how to use SignalR with Blazor and send notifications from API to Blazor using BackgroundService 
            in ASP.NET.
        </p>
    </ContentBody>
</Content>

@code {
    private string Description = "In this post I will teach you to server and client features available in SignalR in .NET. All with live working demo.";
    private string Slug = "server-and-client-features";
    private string PosterPath = "Blogs/SignalR";
    private string Channel = "signalr";
    private string ContentType = "blogs";
    private ushort TotalContents => (ushort)tableOfContents.Contents.Count(content => content.Type.Equals("SignalR", StringComparison.CurrentCultureIgnoreCase));
}
