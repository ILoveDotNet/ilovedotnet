@page "/blogs/oops-abstraction"
@using OOPSDemoComponents
@inherits FragmentNavigationBase
@inject TableOfContents tableOfContents

<Content Slug=@Slug
         PosterPath=@PosterPath
         ContentType="@ContentType"
         FileName=@nameof(Abstraction)>
    <ContentBody>
        <p>
            In our previous post we saw what is <NavLink class="[ underline ]" href="blogs/oops-encapsulation">Encapsulation</NavLink>. I strongly recommend you to go through previous article if 
            you didn't read it. Encapsulation and Abstraction are highly interconnected but still have a different principle. In this post lets see what is Abstraction.
        </p>

        <h3 class="[ font-semibold text-lg ]">Table of Contents</h3>

        <ol class="[ list-decimal ] [ ml-4 ]">
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#what-is-abstraction")" Match="NavLinkMatch.All">
                    What is Abstraction?
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#unlimited-ways-to-write-code")" Match="NavLinkMatch.All">
                    Unlimited ways to write code!!
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#the-purpose-of-abstraction")" Match="NavLinkMatch.All">
                    The Purpose of Abstraction
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#how-does-an-abstraction-look-in-code-csharp")" Match="NavLinkMatch.All">
                    How Does an Abstraction Look in Code (C#)
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#abstraction-hierarchy")" Match="NavLinkMatch.All">
                    Abstraction Hierarchy
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#other-benefits-of-abstraction")" Match="NavLinkMatch.All">
                    Other Benefits of Abstraction
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#summary")" Match="NavLinkMatch.All">
                    Summary
                </NavLink>
            </li>
        </ol>

        <h3 id="what-is-abstraction" class="[ font-semibold text-lg ]">What is Abstraction?</h3>

        <figure>
            <blockquote cite="https://books.google.co.in/books?vid=ISBN9780135974445&redir_esc=y">
                Abstraction is the amplification of the essential and the elimination of irrelevant.
            </blockquote>
            <figcaption>
                —<cite><NavLink class="[ underline ]" href="https://en.wikipedia.org/wiki/Robert_C._Martin" target="_blank">Robert C. Martin</NavLink></cite>
                </figcaption>
        </figure>

        <h3 id="unlimited-ways-to-write-code" class="[ font-semibold text-lg ]">Unlimited ways to write code!!</h3>
        
        <p>
            When we write code we have unlimited options to write code. We can write code in different ways for any task we think of. There are no restrictions. For example, we can write entire 
            application in one class but that will be terrible idea and the reason is our brains are limited and can only handle small things at a time. If this exceeds then our development 
            slows down and we start to introduce lots of bugs.
        </p>

        <GithubGistSnippet Title="OOPS Abstraction Unlimited Ways to Write Code" UserId="fingers10" FileName="ffc72c0989ccab6397e233847d1af273"></GithubGistSnippet>

        <p>
            So its better to avoid <ContentHighlight>freestyle</ContentHighlight> mode and thats why all guidelines and structure for programming exists.
        </p>

        <h3 id="the-purpose-of-abstraction" class="[ font-semibold text-lg ]">The Purpose of Abstraction</h3>

        <p>
            Abstraction helps you focus on one particular task. That is, 
        </p>

        <ul class="[ list-disc ] [ ml-4 ]">
            <li>
                <ContentHighlight>Amplification of the essential</ContentHighlight> = The current task.
            </li>
            <li>
                <ContentHighlight>Elimination of the irrelevant</ContentHighlight> = All other tasks.
            </li>
        </ul>

        <p>
            This way we can split our application into chunks and tackle them one by one.
        </p>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>
        
        <h3 id="how-does-an-abstraction-look-in-code-csharp" class="[ font-semibold text-lg ]">How Does an Abstraction Look in Code (C#)?</h3>

        <p>
            <s>abstract class MyClass</s> ? or <s>interface IMyInterface</s> ? Abstraction doesn't have anything to do with keywords 
            <ContentHighlight>abstract</ContentHighlight> or <ContentHighlight>interface</ContentHighlight>. These are just language specific implementation 
            details. All code is a abstraction.
        </p>

        <ul class="[ list-disc ] [ ml-4 ]">
            <li>
                <ContentHighlight>Good Abstraction</ContentHighlight> = Focusing on single application concern.
            </li>
            <li>
                <ContentHighlight>Bad Abstraction</ContentHighlight> = Thinking of multiple concerns.
            </li>
        </ul>

        <p>
            Abstraction is also related to <ContentHighlight>Single Responsibility Principle (SRP)</ContentHighlight> (first principle of SOLID). If a code 
            violates SRP then it is bad abstraction.
        </p>
        
        <h3 id="abstraction-hierarchy" class="[ font-semibold text-lg ]">Abstraction Hierarchy</h3>

        <p>
            Abstraction allows us to express complex ideas as easily as simple ones. The idea is to break down the complex problem into simple methods.
        </p>

        <GithubGistSnippet Title="OOPS Abstraction Hierarchy" UserId="fingers10" FileName="449d24f46c57c3c310ae120f6dfd8834"></GithubGistSnippet>
        
        <p>
            Here to focus on single task, the trimming functionality is abstracted to new method so that this code doesn't needs to be repeated and called at 
            every place. This new method is an abstraction. It amplifies the essential: <ContentHighlight>WHAT</ContentHighlight> (=NormalizeStudentName - High level detail) 
            the code does and eliminates the irrelevant: <ContentHighlight>HOW</ContentHighlight> (=Method Implementation - Low level detail) the code does it. 
            The code that uses this abstraction doesn't need to worry about how it is implemented.
        </p>

        <p>
            Abstractions are built on top of other abstractions like <ContentHighlight>Replace(" ", "-")</ContentHighlight>, <ContentHighlight>Trim()</ContentHighlight> 
            and <ContentHighlight>Substring(0, 50)</ContentHighlight>. Higher abstraction depends on lower abstractions.
        </p>

        <details open="true">
            <summary>NormalizeStudentName - Higher-order abstractions</summary>
            <div class="[ ml-5 ]">
                <details open="true">
                    <summary>Lower-order abstractions</summary>
                    <div class="[ ml-6 ]">
                        <ul class="[ list-disc ] [ ml-4 ]">
                            <li>Replace</li>
                            <li>Trim</li>
                            <li>Substring</li>
                        </ul>
                    </div>
                </details>
            </div>
        </details>

        <figure>
            <img src="./image/blogs/oops/abstraction/abstraction order.png" alt="Abstraction Hierarchy?" class="[ w-full ]" />
        </figure>

        <GithubGistSnippet Title="OOPS Abstraction Hierarchy" UserId="fingers10" FileName="3be223a94ffe5957c4251e0c743fe118"></GithubGistSnippet>

        <DemoSnippet Title="Abstracted Email Address">
            <p class="[ text-black ] [ dark:text-white ]">
                <b>
                    Scenario - Let's try creating a email address that is properly abstracted from <ContentHighlight>string</ContentHighlight>.
                </b>
            </p>
            <ErrorBoundary @ref="@errorBoundary">
                <ChildContent>
                    <AbstractionHierarchy></AbstractionHierarchy>
                </ChildContent>
                <ErrorContent>
                    <div class="[ bg-red-500 ]">
                        <p class="[ text-white ]">Invalid Email Address.</p>
                    </div>
                </ErrorContent>
            </ErrorBoundary>

            <button type="button" class="[ bg-fuchsia-500 ] [ text-white ] [ px-4 py-2 ] [ rounded-md ] [ text-white ]" @onclick="Recover">
                Click to try again
                <svg xmlns="http://www.w3.org/2000/svg" class="[ icon icon-tabler icon-tabler-activity ] [ inline ]" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                    <path d="M3 12h4l3 8l4 -16l3 8h4"></path>
                </svg>
            </button>
        </DemoSnippet>

        <p>
            This class represents Email Address and it has hierarchy of abstractions. It abstracts away the work with strings and creates its own higher order abstraction such the client code 
            can focus on tests related to Email Address than with strings. As a result we get the below graph of abstractions. Thus allowing us to build complex logic as easily as simple ones. 
            This will be within our brain capacity and doesn't slow down development and won't introduce large amoun of bugs. Thus helps to focus on one task at a time and focus on WHAT's, not 
            HOW's.
        </p>

        <details open="true">
            <summary>Even higher-order abstractions</summary>
            <div class="[ ml-4 ]">
                <details open="true">
                    <summary>Higher-order abstractions</summary>
                    <div class="[ ml-4 ]">
                        <details open="false">
                            <summary>Lower-order abstractions</summary>
                        </details>
                    </div>
                </details>
            </div>
        </details>

        <h3 id="other-benefits-of-abstraction" class="[ font-semibold text-lg ]">Other Benefits of Abstraction</h3>
        
        <p>
            Abstraction is not just for code reuse. We should introduce this method even if it is used in one place. Thats because its easier to read the following code than to understand the 
            implementation. It is also clear at highlevel and gives better code simplification.
        </p>

        <GithubGistSnippet Title="OOPS Abstraction Benefits" UserId="fingers10" FileName="525a42f72a5baf77b95572cf43bd55f1"></GithubGistSnippet>
        
        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="summary" class="[ font-semibold text-lg ]">Summary</h3>

        <p>
            In this post, we learn't what is abstraction in oops and the principle behind it. It means amplification of the essential and elimination of the 
            irrelevant. It helps to focus on,
        </p>

        <ul class="[ list-disc ] [ ml-4 ]">
            <li>one task at a time</li>
            <li>on WHAT's (intent), not HOW's (implementation details)</li>
        </ul>

        <p>
            Abstraction can form Hierarchies which helps express complex ideas as easily as simple ideas.
        </p>
    </ContentBody>
</Content>

@code {
    private string Slug = "oops-abstraction";
    private string PosterPath = "Blogs/OOPS";
    private string ContentType = "blogs";
    
    private ErrorBoundary errorBoundary = default!;

    private void Recover()
    {
        errorBoundary?.Recover();
    }
}