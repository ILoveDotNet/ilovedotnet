@page "/blogs/improve-security-with-dependency-management-and-sbom-in-dotnet"
@inherits BasePage

<Content FileName=@nameof(DependencyManagementAndSBOM) UseNewTableOfContentsMenu=true>
  <ContentBody>
    <What>
      <p>
        Think your application is secure because you wrote the code yourself? <ContentHighlight>Think again.</ContentHighlight> 
        On average, <ContentHighlight>80% of your application</ContentHighlight> comes from third-party dependencies—and every 
        single one is a potential security risk. In this article, we'll explore <ContentHighlight>dependency management</ContentHighlight> 
        and <ContentHighlight>Software Bill of Materials (SBOM)</ContentHighlight> in .NET, showing you how to regain control 
        over your software supply chain.
      </p>
    </What>

    <Why>
      <p>
        The software supply chain is under attack. Remember <ContentHighlight>Log4j in 2021</ContentHighlight>? That single 
        vulnerability in a widely-used logging library compromised millions of applications worldwide—and organizations are 
        <ContentHighlight>still finding instances in 2025</ContentHighlight>. Why? Because most companies have no idea what 
        components are buried deep in their dependency trees.
      </p>
      <p>
        Here's the harsh reality: third-party components can be <ContentHighlight>abandoned</ContentHighlight> by their 
        creators, <ContentHighlight>compromised</ContentHighlight> by attackers, or simply <ContentHighlight>contain 
        undiscovered vulnerabilities</ContentHighlight>. The 2018 EventStream attack showed how easily a malicious actor 
        can take over a popular package and inject bitcoin-stealing code. SolarWinds proved that even trusted vendors can 
        distribute compromised software.
      </p>
      <p>
        But here's what keeps security teams up at night: <ContentHighlight>transitive dependencies</ContentHighlight>—the 
        dependencies of your dependencies. Your PDF library might be using Log4j without you knowing it. You're not just 
        responsible for the 5 packages you directly reference, but also the <ContentHighlight>75+ packages they pull in</ContentHighlight>.
      </p>
      <p>
        The US government now <ContentHighlight>requires an SBOM</ContentHighlight> for any software sold or leased to federal 
        agencies. This isn't bureaucracy—it's recognition that supply chain security is critical infrastructure. If you can't 
        answer "what's in my software?" within minutes of a vulnerability disclosure, you're already too late.
      </p>
    </Why>

    <How>
      <p>
        Securing your dependency chain requires a systematic approach. Let's build a complete governance framework that gives 
        you visibility, control, and rapid response capabilities.
      </p>

      <h4>Understanding the Risk Landscape</h4>

      <p>
        Before implementing solutions, understand what you're protecting against. Third-party dependencies face several 
        critical threats:
      </p>

      <p>
        <strong>Abandoned Components:</strong> Developers move on. Projects get neglected. When a component is abandoned, 
        bugs never get fixed, vulnerabilities remain unpatched, and compatibility with newer frameworks degrades. Running 
        .NET Core 3 components on .NET 8 isn't just risky—.NET Core 3 has been <ContentHighlight>out of support for years</ContentHighlight>.
      </p>

      <p>
        <strong>Compromised Packages:</strong> Attackers can inject malicious code into legitimate packages through several vectors:
      </p>
      <ul>
        <li>Taking over abandoned projects with authentic-looking contributions</li>
        <li>Compromising the vendor's build pipeline (like SolarWinds)</li>
        <li>Publishing typosquatting packages with similar names</li>
        <li>Social engineering package maintainers to hand over access</li>
      </ul>

      <p>
        <strong>Licensing Conflicts:</strong> Use a GPL-licensed component in your proprietary software? You might be 
        <ContentHighlight>legally required to open-source your entire application</ContentHighlight>. Most developers 
        never check licenses until it's too late.
      </p>

      <p>
        <strong>Disclosed Vulnerabilities:</strong> When a CVE is published, attackers immediately start scanning for victims. 
        The race is on—can you patch faster than they can exploit?
      </p>

      <h4>Step 1: Establish Component Governance</h4>

      <p>
        No more grabbing packages from NuGet on a whim. Every component must go through a vetting process before it enters 
        your codebase.
      </p>

      <p>
        <strong>Create an Architectural Decision Record (ADR):</strong> Document why you need this component. An ADR should include:
      </p>

<CodeSnippet CssClass="language-markdown">
# ADR: Adding Stripe.NET Payment Library

## Status
Proposed

## Context
We need to process credit card payments securely. Building our own payment 
processing would be costly and risky given PCI DSS compliance requirements.

## Decision Drivers
- PCI DSS compliance requirements
- Need for production-ready payment processing
- Developer experience and documentation quality
- Long-term vendor stability and support

## Considered Options
1. Stripe.NET
2. Braintree SDK
3. PayPal Checkout SDK

## Pros and Cons

### Stripe.NET
- ✅ 54 million downloads (proven track record)
- ✅ Active development (weekly releases)
- ✅ Comprehensive documentation
- ✅ MIT license (compatible with our proprietary code)
- ✅ No known vulnerabilities in last 2 years
- ✅ Strong security disclosure program
- ❌ Requires Stripe merchant account

### Decision
Selected Stripe.NET based on community adoption, security track record, 
and licensing compatibility.

## Consequences
- Development team needs training on Stripe API
- Monthly dependency review required
- Must monitor Stripe security advisories
</CodeSnippet>

      <p>
        <strong>Classify and Inventory:</strong> Rate each component's criticality. A library handling credit cards gets 
        <ContentHighlight>critical classification</ContentHighlight>; a utility for generating QR codes gets lower priority.
      </p>

<CodeSnippet CssClass="language-csharp">
public enum ComponentCriticality
{
    Critical,   // Handles PII, auth, payments - immediate patch required
    High,       // Core business logic - patch within 48 hours
    Medium,     // Supporting features - patch within 1 week
    Low         // Nice-to-have features - patch during normal cycle
}

public class ComponentMetadata
{
    public string Name { get; set; }
    public string Version { get; set; }
    public ComponentCriticality Criticality { get; set; }
    public string License { get; set; }
    public DateTime LastReviewed { get; set; }
    public DateTime NextReviewDue { get; set; }
    public List&lt;string&gt; TransitiveDependencies { get; set; }
    public string VendorSecurityContact { get; set; }
}
</CodeSnippet>

      <h4>Step 2: Security Assessment Process</h4>

      <p>
        Before approving any component, run it through comprehensive security checks:
      </p>

      <p>
        <strong>1. Check CVE Databases:</strong> Search for known vulnerabilities. Even if vulnerabilities exist, they 
        might not apply to your use case—but you need to know about them.
      </p>

<CodeSnippet CssClass="language-bash">
# Check for vulnerabilities in your project
dotnet list package --vulnerable

# Check for outdated packages
dotnet list package --outdated
</CodeSnippet>

      <p>
        <strong>2. Run Static Analysis:</strong> If source code is available, run SAST tools against it.
      </p>

      <p>
        <strong>3. Review the Project:</strong> Visit the GitHub repository. Look for:
      </p>
      <ul>
        <li><strong>Recent commits:</strong> Active development is a good sign</li>
        <li><strong>Issue resolution time:</strong> How fast do maintainers respond to bugs?</li>
        <li><strong>Security policy:</strong> Do they have responsible disclosure?</li>
        <li><strong>Community size:</strong> More stars/forks = more eyes on the code</li>
        <li><strong>Dependencies:</strong> What transitive dependencies will this bring in?</li>
      </ul>

      <p>
        <strong>4. Validate the License:</strong> Ensure it's compatible with your software's license. Use AI to help 
        interpret complex legal terms if needed.
      </p>

      <p>
        <strong>5. OSINT Research:</strong> Search for any security incidents involving the vendor or component. Have 
        they been breached before? How did they respond?
      </p>

      <h4>Step 3: Generate and Maintain an SBOM</h4>

      <p>
        A <ContentHighlight>Software Bill of Materials (SBOM)</ContentHighlight> is your complete inventory—every component, 
        every version, every transitive dependency. It's the foundation of supply chain security.
      </p>

      <p>
        <strong>What an SBOM Contains:</strong>
      </p>
      <ul>
        <li>Component name and version</li>
        <li>Vendor/publisher information</li>
        <li>Licensing details</li>
        <li>Dependency relationships</li>
        <li>Cryptographic hash for verification</li>
      </ul>

      <p>
        <strong>Generate SBOM with Microsoft's Free Tool:</strong>
      </p>

<CodeSnippet CssClass="language-bash">
# Install the SBOM tool
dotnet tool install --global Microsoft.Sbom.DotNetTool

# Generate SBOM in SPDX JSON format
sbom-tool generate -b /path/to/build/output -bc /path/to/project -pn "MyApp" -pv "1.0.0" -ps "MyCompany" -nsb https://mycompany.com

# For Example at the root of your project,
sbom-tool generate -b ./ -bc ./ -pn ILoveDotNet -pv 1.0.0 -ps ILoveDotNet -pm

# The tool creates a manifest with cryptographic hash for tamper detection
</CodeSnippet>

      <p>
        The generated SBOM looks like this (simplified):
      </p>

<CodeSnippet CssClass="language-json">
{
  "spdxVersion": "SPDX-2.2",
  "name": "MyApp",
  "packages": [
    {
      "name": "Newtonsoft.Json",
      "versionInfo": "13.0.3",
      "supplier": "Organization: Newtonsoft",
      "licenseConcluded": "MIT",
      "checksums": [
        {
          "algorithm": "SHA256",
          "checksumValue": "abc123..."
        }
      ]
    },
    {
      "name": "System.Text.Json",
      "versionInfo": "8.0.0",
      "supplier": "Organization: Microsoft"
    }
  ],
  "relationships": [
    {
      "relationshipType": "DEPENDS_ON",
      "relatedSpdxElement": "Newtonsoft.Json"
    }
  ]
}
</CodeSnippet>

      <p>
        <strong>Integrate SBOM Generation into CI/CD:</strong> Make SBOM generation automatic. Every build should produce 
        a fresh, signed SBOM.
      </p>

<CodeSnippet CssClass="language-yaml">
# Azure DevOps Pipeline example
- task: DotNetCoreCLI@@2
  displayName: 'Build Application'
  inputs:
    command: 'build'
    projects: '**/*.csproj'

- task: PowerShell@@2
  displayName: 'Generate SBOM'
  inputs:
    targetType: 'inline'
    script: |
      sbom-tool generate `
        -b $(Build.ArtifactStagingDirectory) `
        -bc $(Build.SourcesDirectory) `
        -pn "$(Build.Repository.Name)" `
        -pv "$(Build.BuildNumber)" `
        -ps "MyOrganization"

- task: PublishBuildArtifacts@@1
  displayName: 'Publish SBOM'
  inputs:
    PathtoPublish: '_manifest/spdx_2.2'
    ArtifactName: 'sbom'
</CodeSnippet>

      <h4>Step 4: Implement Private Package Repository</h4>

      <p>
        Never pull dependencies directly from public NuGet in production builds. Instead, maintain a <ContentHighlight>
        private repository</ContentHighlight> with vetted, approved packages.
      </p>

      <p>
        <strong>Why Private Repositories Matter:</strong>
      </p>
      <ul>
        <li><strong>Control:</strong> You decide when to update, not package authors</li>
        <li><strong>Stability:</strong> Packages can't disappear from NuGet and break your builds</li>
        <li><strong>Security:</strong> Scan packages before they enter your environment</li>
        <li><strong>Compliance:</strong> Maintain audit trail of approved components</li>
      </ul>

      <p>
        <strong>Setup with Azure Artifacts:</strong>
      </p>

<CodeSnippet CssClass="language-bash">
# Create a feed in Azure DevOps Artifacts
# Then configure your NuGet.Config to use it

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;configuration&gt;
  &lt;packageSources&gt;
    &lt;clear /&gt;
    &lt;!-- Private feed only - blocks direct access to public NuGet --&gt;
    &lt;add key="MyCompanyFeed" 
         value="https://pkgs.dev.azure.com/myorg/_packaging/myfeed/nuget/v3/index.json" /&gt;
  &lt;/packageSources&gt;
  &lt;packageSourceCredentials&gt;
    &lt;MyCompanyFeed&gt;
      &lt;add key="Username" value="AzureDevOps" /&gt;
      &lt;add key="ClearTextPassword" value="%AZURE_DEVOPS_PAT%" /&gt;
    &lt;/MyCompanyFeed&gt;
  &lt;/packageSourceCredentials&gt;
&lt;/configuration&gt;
</CodeSnippet>

      <p>
        <strong>Vetting Workflow:</strong>
      </p>
      <ol>
        <li>Developer requests component via ADR</li>
        <li>Security team runs assessment (CVE check, SAST, license review)</li>
        <li>Approved packages are uploaded to private feed</li>
        <li>Developers can now reference the component</li>
        <li>Regular reviews ensure packages stay current</li>
      </ol>

      <h4>Step 5: Define Update Strategy and SLAs</h4>

      <p>
        Not every package update needs immediate deployment. Define <ContentHighlight>Service Level Agreements (SLAs)</ContentHighlight> 
        based on vulnerability severity:
      </p>

<CodeSnippet CssClass="language-csharp">
public class PatchingSLA
{
    public static readonly Dictionary&lt;VulnerabilitySeverity, TimeSpan&gt; ResponseTimes = new()
    {
        { VulnerabilitySeverity.Critical, TimeSpan.FromHours(24) },
        { VulnerabilitySeverity.High, TimeSpan.FromHours(48) },
        { VulnerabilitySeverity.Medium, TimeSpan.FromDays(7) },
        { VulnerabilitySeverity.Low, TimeSpan.FromDays(30) }
    };
}

public enum VulnerabilitySeverity
{
    Critical,  // Active exploitation, RCE, auth bypass
    High,      // Significant security impact, no known exploits yet
    Medium,    // Moderate risk, mitigations available
    Low        // Minimal risk or requires unlikely conditions
}
</CodeSnippet>

      <p>
        <strong>Regular Update Schedule:</strong> For non-security updates, establish a cadence:
      </p>
      <ul>
        <li><strong>Monthly reviews:</strong> Check for new versions of critical components</li>
        <li><strong>Quarterly updates:</strong> Update medium-criticality components</li>
        <li><strong>Annual reviews:</strong> Re-evaluate all component choices</li>
      </ul>

      <p>
        <strong>Wait Before Updating:</strong> Don't jump on the latest version immediately. Give new releases 2-4 weeks 
        to shake out bugs that slipped past the vendor's testing.
      </p>

      <h4>Step 6: Automate Vulnerability Monitoring</h4>

      <p>
        Set up automated scanning in your CI/CD pipeline:
      </p>

<CodeSnippet CssClass="language-yaml">
# GitHub Actions example
name: Security Scan

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  schedule:
    # Run daily at 2 AM
    - cron: '0 2 * * *'

jobs:
  security-scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@@v3
      
      - name: Setup .NET
        uses: actions/setup-dotnet@@v3
        with:
          dotnet-version: '8.0.x'
      
      - name: Restore dependencies
        run: dotnet restore
      
      - name: Check for vulnerable packages
        run: |
          dotnet list package --vulnerable --include-transitive 2&gt;&amp;1 | tee vulnerability-scan.txt
          
          # Fail the build if critical or high vulnerabilities are found
          if grep -i "critical\|high" vulnerability-scan.txt; then
            echo "Critical or high vulnerabilities detected!"
            exit 1
          fi
      
      - name: Generate SBOM
        run: |
          dotnet tool install --global Microsoft.Sbom.DotNetTool
          sbom-tool generate -b ./bin -bc ./ -pn MyApp -pv 1.0.0 -ps MyOrg
      
      - name: Upload SBOM
        uses: actions/upload-artifact@@v3
        with:
          name: sbom
          path: _manifest/spdx_2.2/
</CodeSnippet>

      <h4>Step 7: Managing the NuGet Package Manager in Visual Studio</h4>

      <p>
        Visual Studio's NuGet Package Manager is your frontline tool for dependency management. Here's how to use it effectively:
      </p>

      <p>
        <strong>View Installed Packages:</strong> Navigate to <code>Tools &gt; NuGet Package Manager &gt; Manage NuGet Packages 
        for Solution</code>. The <strong>Installed</strong> tab shows all direct dependencies plus <ContentHighlight>transitive 
        dependencies</ContentHighlight>. Notice how 5 direct packages might pull in 75+ transitive dependencies.
      </p>

      <p>
        <strong>Identify Vulnerable Packages:</strong> Visual Studio highlights packages with known vulnerabilities, showing 
        severity levels (Critical, High, Medium, Low). Click the warning icon to see CVE details and recommended actions.
      </p>

<CodeSnippet CssClass="language-plaintext">
Example: Newtonsoft.Json 12.0.1
⚠️ High Severity Vulnerability Detected
CVE-2024-12345: Improper Input Validation
Recommendation: Update to version 13.0.3 or later
</CodeSnippet>

      <p>
        <strong>Update Packages Safely:</strong> The <strong>Updates</strong> tab shows available updates. Don't blindly 
        update everything—review release notes first. Major version changes can introduce breaking changes.
      </p>

      <p>
        <strong>Configure Private Feeds:</strong> In <code>Tools &gt; Options &gt; NuGet Package Manager &gt; Package Sources</code>, 
        add your private feed and <ContentHighlight>remove or disable public NuGet.org</ContentHighlight> to prevent 
        unapproved package installation.
      </p>

      <h4>Real-World Example: The Log4j Response</h4>

      <p>
        When Log4Shell (CVE-2021-44228) was disclosed in December 2021, organizations with proper dependency management responded in hours. Those without it? Many are still cleaning up in 2025.
      </p>

      <p>
        <strong>With SBOM and Governance:</strong>
      </p>
      <ol>
        <li>Run: <code>grep -r "log4j" sbom.json</code></li>
        <li>Immediately identify all affected applications</li>
        <li>Pull patched version from private repository (already vetted)</li>
        <li>Deploy emergency patch using existing CI/CD pipeline</li>
        <li>Total time: 4-6 hours</li>
      </ol>

      <p>
        <strong>Without SBOM and Governance:</strong>
      </p>
      <ol>
        <li>Manually search through hundreds of applications</li>
        <li>Check if any use Java libraries (not just direct Log4j usage)</li>
        <li>Download patch from public repository (is it safe? who knows?)</li>
        <li>Test patch against each application individually</li>
        <li>Deploy manually because no automation exists</li>
        <li>Total time: Days to weeks (and you still miss some instances)</li>
      </ol>

      <h4>Additional Tools and Options</h4>

      <p>
        Beyond Microsoft's SBOM tool, consider these alternatives:
      </p>

      <ul>
        <li><strong>Syft:</strong> Open-source SBOM generator supporting multiple languages</li>
        <li><strong>CycloneDX:</strong> Modern SBOM standard with vulnerability disclosure support</li>
        <li><strong>GitHub Dependency Graph:</strong> Automatic SBOM generation for GitHub repositories</li>
        <li><strong>OWASP Dependency-Check:</strong> Identifies known vulnerabilities in project dependencies</li>
      </ul>

<CodeSnippet CssClass="language-bash">
# Using Syft to generate SBOM
syft packages dir:/path/to/project -o spdx-json &gt; sbom.spdx.json

# Using CycloneDX with .NET
dotnet tool install --global CycloneDX
dotnet CycloneDX /path/to/project.csproj -o /output -j
</CodeSnippet>

      <h4>Licensing Due Diligence</h4>

      <p>
        Don't overlook licensing. A GPL-licensed component in proprietary software can create <ContentHighlight>legal 
        liability</ContentHighlight>. Common open-source licenses:
      </p>

      <ul>
        <li><strong>MIT/Apache 2.0:</strong> Permissive, safe for commercial use</li>
        <li><strong>BSD:</strong> Permissive with some restrictions</li>
        <li><strong>GPL/LGPL:</strong> Copyleft licenses—require derivative works to use same license</li>
        <li><strong>AGPL:</strong> Like GPL but applies to network services too</li>
      </ul>

      <p>
        When in doubt, use AI to interpret licensing terms: "Explain how the GPL 3.0 license affects my proprietary 
        .NET application that uses this library."
      </p>
    </How>

    <Summary>
      <p>
        Dependency management isn't optional—it's <ContentHighlight>critical infrastructure</ContentHighlight>. Every third-party 
        component is a potential attack vector, and you're responsible for all of them, including transitive dependencies.
      </p>
      <p>
        Build a governance framework: vet components with ADRs, maintain a private repository, generate SBOMs automatically, 
        and define clear SLAs for patching vulnerabilities. When the next Log4j-scale incident hits, you'll respond in hours, 
        not weeks.
      </p>
      <p>
        The supply chain is under attack. The question isn't whether you'll be targeted—it's whether you'll be ready. Start 
        with an SBOM, establish governance, and never trust a dependency blindly again.
      </p>
    </Summary>
  </ContentBody>
</Content>
