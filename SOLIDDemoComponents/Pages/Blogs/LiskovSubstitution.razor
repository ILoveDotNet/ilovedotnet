@page "/blogs/liskov-substitution-principle-in-solid"
@inherits FragmentNavigationBase
@inject TableOfContents tableOfContents

<Content Slug=@Slug
         PosterPath=@PosterPath
         Channel="@Channel"
         ContentType="@ContentType"
         TotalContents=@TotalContents
         Type="SOLID"
         FileName=@nameof(LiskovSubstitution)>
    <ContentBody>
        <p>
            In this article, let's learn about <ContentHighlight>Liskov Substitution Principle</ContentHighlight> in <ContentHighlight>SOLID</ContentHighlight> Principles 
            in .NET.
        </p>

        <p>
            <strong>Note:</strong> If you have not done so already, I recommend you read the article on
            <NavLink class="[ underline ]" href="blogs/open-closed-principle-in-solid" Match="NavLinkMatch.All">Open Closed Principle in SOLID</NavLink>.
        </p>

        <h3 class="[ font-semibold text-lg ]">Table of Contents</h3>
        
        <ol class="[ list-decimal ] [ ml-4 ]">
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#introduction")" Match="NavLinkMatch.All">
                    Introduction
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#when-to-apply-lsp")" Match="NavLinkMatch.All">
                    When to apply LSP?
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#demo")" Match="NavLinkMatch.All">
                    Demo
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#advantages")" Match="NavLinkMatch.All">
                    Advantages
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#summary")" Match="NavLinkMatch.All">
                    Summary
                </NavLink>
            </li>
        </ol>

        <h3 id="introduction" class="[ font-semibold text-lg ]">Introduction</h3>
        
        <p>
            The <ContentHighlight>Liskov Substitution Principle (LSP)</ContentHighlight>, which has been around since 1987. The LSP is a fundamental principle of 
            object-oriented programming and is part of the SOLID principles. LSP states that <ContentHighlight>objects in a program should be replaceable with instances of 
            their subtypes without altering the correctness of the program</ContentHighlight>. In other words, if <ContentHighlight>class B</ContentHighlight> is a subtype of 
            <ContentHighlight>class A</ContentHighlight>, then objects of <ContentHighlight>type B</ContentHighlight> should be able to be used wherever objects of 
            <ContentHighlight>type A</ContentHighlight> are expected, without causing any unexpected behavior or violating any contracts.
        </p>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="when-to-apply-lsp" class="[ font-semibold text-lg ]">When to apply LSP?</h3>

        <p>
            Use the Liskov Substitution Principle <ContentHighlight>when you have a class hierarchy, and you want to ensure that subclasses can be used interchangeably with 
            their superclass</ContentHighlight>. It is particularly useful when working with <ContentHighlight>interfaces</ContentHighlight> or <ContentHighlight>abstract</ContentHighlight> 
            classes that define contracts for behavior, allowing different implementations to be used seamlessly.
        </p>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="demo" class="[ font-semibold text-lg ]">Demo</h3>

        <p>
            Suppose we have a base class called <ContentHighlight>Vehicle</ContentHighlight>, which has a method <ContentHighlight>Move()</ContentHighlight> that receives a 
            key to start the vehicle. We also have a subclass called <ContentHighlight>Truck</ContentHighlight>, which inherits from <ContentHighlight>Vehicle</ContentHighlight>. 
            Both classes have a method with the same signature, but their implementations may differ.
        </p>

        <GithubGistSnippet Title="LSP - Liskov Substitution Principle - Before" UserId="fingers10" FileName="7cf120f1d8c9378ad47eaa9487e9bb00"></GithubGistSnippet>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <p>
            The Liskov Substitution Principle ensures that we can replace an instance of <ContentHighlight>Truck</ContentHighlight> with an instance of 
            <ContentHighlight>Vehicle</ContentHighlight> and still expect the same behavior. Let's see how this works:
        </p>

        <GithubGistSnippet Title="LSP - Liskov Substitution Principle - After" UserId="fingers10" FileName="f6d018624071013046070963e89f553b"></GithubGistSnippet>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <p>
            Even though the <ContentHighlight>Vehicle</ContentHighlight> object is of type <ContentHighlight>Truck</ContentHighlight>, we can treat it as an instance of 
            <ContentHighlight>Vehicle</ContentHighlight> and call the <ContentHighlight>Move()</ContentHighlight> method. This demonstrates the substitutability aspect of the 
            Liskov Substitution Principle.
        </p>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="advantages" class="[ font-semibold text-lg ]">Advantages</h3>

        <p>
            The Open Closed Principle has several advantages, including:
        </p>

        <ul>
            <li><ContentHighlight>Code Reusability</ContentHighlight>: Create a hierarchy of classes that can be easily reused in different contexts. Subclasses can be substituted for their base class, allowing for flexible and extensible code.</li>
            <li><ContentHighlight>Polymorphism</ContentHighlight>: Objects of different types can be treated uniformly through a shared interface or base class. This promotes code flexibility and simplifies interactions between objects.</li>
            <li><ContentHighlight>Modularity and Maintainability</ContentHighlight>: Helps in creating modular code structures that are easy to understand and maintain. It allows developers to focus on specific behaviors in subclasses while ensuring compatibility with the base class.</li>
            <li><ContentHighlight>Testability</ContentHighlight>: Promotes testability by allowing you to write meaningful and focused tests for individual classes or interfaces. Subclasses can be tested independently, and their behavior can be validated without relying on the specifics of the base class.</li>
        </ul>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="summary" class="[ font-semibold text-lg ]">Summary</h3>

        <p>
            The <ContentHighlight>Liskov Substitution Principle</ContentHighlight> is a fundamental principle in object-oriented programming that ensures substitutability of 
            objects in a hierarchy. It emphasizes that <ContentHighlight>subclasses should be able to substitute their base class without affecting the correctness of the 
            program</ContentHighlight>.
        </p>
        
        <p>
            By adhering to the LSP, you create code that is <ContentHighlight>reusable</ContentHighlight>, <ContentHighlight>extensible</ContentHighlight>, and 
            <ContentHighlight>easily maintainable</ContentHighlight>. It promotes <ContentHighlight>modularity</ContentHighlight> and allows for <ContentHighlight>polymorphic</ContentHighlight> 
            behavior, where objects of different types can be treated uniformly. The LSP also improves testability by enabling focused testing of individual classes or 
            interfaces.
        </p>
    </ContentBody>
</Content>

@code {
    private string Slug = "liskov-substitution-principle-in-solid";
    private string PosterPath = "Blogs/SOLID";
    private string Channel = "solid";
    private string ContentType = "blogs";
    private ushort TotalContents => (ushort)tableOfContents.Contents.Count(content => content.Channel.Equals("SOLID", StringComparison.CurrentCultureIgnoreCase));
}