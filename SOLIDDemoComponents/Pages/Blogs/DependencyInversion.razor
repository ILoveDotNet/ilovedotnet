@page "/blogs/dependency-inversion-principle-in-solid"
@inherits FragmentNavigationBase
@inject TableOfContents tableOfContents

<Content Slug=@Slug
         PosterPath=@PosterPath
         Channel="@Channel"
         ContentType="@ContentType"
         TotalContents=@TotalContents
         Type="SOLID"
         FileName=@nameof(DependencyInversion)>
    <ContentBody>
        <p>
            In this article, let's learn about <ContentHighlight>Dependency Inversion Principle</ContentHighlight> in <ContentHighlight>SOLID</ContentHighlight> Principles 
            in .NET.
        </p>

        <p>
            <strong>Note:</strong> If you have not done so already, I recommend you read the article on
            <NavLink class="[ underline ]" href="blogs/interface-segregation-principle-in-solid" Match="NavLinkMatch.All">Interface Segregation Principle in SOLID</NavLink>.
        </p>

        <h3 class="[ font-semibold text-lg ]">Table of Contents</h3>
        
        <ol class="[ list-decimal ] [ ml-4 ]">
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#introduction")" Match="NavLinkMatch.All">
                    Introduction
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#when-to-apply-dip")" Match="NavLinkMatch.All">
                    When to apply DIP?
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#demo")" Match="NavLinkMatch.All">
                    Demo
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#advantages")" Match="NavLinkMatch.All">
                    Advantages
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#summary")" Match="NavLinkMatch.All">
                    Summary
                </NavLink>
            </li>
        </ol>

        <h3 id="introduction" class="[ font-semibold text-lg ]">Introduction</h3>
        
        <p>
            The <ContentHighlight>Dependency Inversion Principle (DIP)</ContentHighlight> promotes <ContentHighlight>loose coupling</ContentHighlight> and 
            <ContentHighlight>flexibility</ContentHighlight> in software design.
        </p>

        <p>
            In traditional software design, <ContentHighlight>high-level modules often depend on low-level modules</ContentHighlight>, leading to <ContentHighlight>tight 
            coupling</ContentHighlight> and <ContentHighlight>code fragility</ContentHighlight>. Changes in low-level modules can have a <ContentHighlight>cascading effect</ContentHighlight> 
            on higher-level modules, making the <ContentHighlight>system difficult to maintain and modify</ContentHighlight>. The Dependency Inversion Principle addresses these issues 
            by <ContentHighlight>inverting the dependencies</ContentHighlight>, allowing for greater flexibility and extensibility.
        </p>

        <p>
            The <ContentHighlight>Dependency Inversion Principle</ContentHighlight> consists of two main ideas:

            <ol class="[ list-decimal ] [ ml-4 ]">
                <li><ContentHighlight>High-level modules should not depend on low-level modules</ContentHighlight>. Both should depend on <ContentHighlight>abstractions</ContentHighlight>.</li>
                <li><ContentHighlight>Abstractions should not depend on details. Details should depend on abstractions.</ContentHighlight></li>
            </ol>
        </p>

        <p>
            By following these principles, we can decouple modules and introduce abstraction layers, which reduce dependencies and improve code maintainability.
        </p>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="when-to-apply-dip" class="[ font-semibold text-lg ]">When to apply DIP?</h3>

        <p>
            <ContentHighlight>Dependency Inversion</ContentHighlight> is particularly useful in scenarios where there is a need for <ContentHighlight>flexibility and the ability to 
            switch implementations without modifying the high-level modules</ContentHighlight>. It is beneficial in cases where different implementations of a specific functionality 
            or service need to be supported, such as working with different databases, external APIs, or third-party libraries.
        </p>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="demo" class="[ font-semibold text-lg ]">Demo</h3>

        <p>
            Let's consider a scenario where an <ContentHighlight>application generates sales reports using a database</ContentHighlight>. Initially, the code is 
            <ContentHighlight>tightly coupled</ContentHighlight> to a specific database type <ContentHighlight>SQL Server</ContentHighlight>. 
        </p>

        <GithubGistSnippet Title="DIP - Dependency Inversion Principle - Before" UserId="fingers10" FileName="4f8464eedd15245e3b5920b2e8d7c9aa"></GithubGistSnippet>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <p>
            However, we want to make the application adaptable to support different database types, such as <ContentHighlight>Cassandra</ContentHighlight>.
        </p>

        <GithubGistSnippet Title="DIP - Dependency Inversion Principle - After" UserId="fingers10" FileName="cd2241156cf9885672312f0ebcf3ba9c"></GithubGistSnippet>

        <p>
            In the above code, we introduce the <ContentHighlight>IDatabase</ContentHighlight> interface, which defines the common database operations. Both the 
            <ContentHighlight>SqlServerDatabase</ContentHighlight> and <ContentHighlight>CassandraDatabase</ContentHighlight> classes implement this interface, representing 
            different database types. The <ContentHighlight>SalesReport class</ContentHighlight> no longer depends on the <ContentHighlight>concrete</ContentHighlight> 
            database implementations but instead relies on the <ContentHighlight>abstraction</ContentHighlight> provided by the <ContentHighlight>IDatabase interface</ContentHighlight>.
        </p>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="advantages" class="[ font-semibold text-lg ]">Advantages</h3>

        <p>
            The Dependency Inversion Principle has several advantages, including:
        </p>

        <ul>
            <li><ContentHighlight>Loose coupling</ContentHighlight>: The Dependency Inversion Principle promotes loose coupling between modules, making the codebase more maintainable and extensible.</li>
            <li><ContentHighlight>Easy to switch implementations</ContentHighlight>: By depending on abstractions rather than concrete implementations, it becomes easier to switch between different implementations of a service or functionality without modifying the high-level modules.</li>
            <li><ContentHighlight>Testability</ContentHighlight>: Dependency Inversion facilitates easier unit testing by allowing the injection of mock or fake implementations during testing.</li>
        </ul>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="summary" class="[ font-semibold text-lg ]">Summary</h3>

        <p>
            The <ContentHighlight>Dependency Inversion Principle</ContentHighlight> is a crucial aspect of SOLID design principles. By <ContentHighlight>inverting dependencies</ContentHighlight>, 
            it promotes <ContentHighlight>loose coupling</ContentHighlight> and <ContentHighlight>flexibility</ContentHighlight> in software systems. In this article, we 
            explored the concept of Dependency Inversion, its benefits, and provided C# code examples to demonstrate its implementation. By adhering to this principle, 
            developers can create more maintainable, extensible, and testable codebases.
        </p>
    </ContentBody>
</Content>

@code {
    private string Slug = "dependency-inversion-principle-in-solid";
    private string PosterPath = "Blogs/SOLID";
    private string Channel = "solid";
    private string ContentType = "blogs";
    private ushort TotalContents => (ushort)tableOfContents.Contents.Count(content => content.Channel.Equals("SOLID", StringComparison.CurrentCultureIgnoreCase));
}