@page "/blogs/open-closed-principle-in-solid"
@inherits FragmentNavigationBase
@inject TableOfContents tableOfContents

<Content 
         Description=@Description
         Slug=@Slug
         PosterPath=@PosterPath
         Channel="@Channel"
         ContentType="@ContentType"
         TotalContents=@TotalContents
         Type="SOLID"
         FileName=@nameof(OpenClosed)>
    <ContentBody>
        <p>
            In this article, let's learn about <ContentHighlight>Open Closed Principle</ContentHighlight> in <ContentHighlight>SOLID</ContentHighlight> Principles 
            in .NET.
        </p>

        <p>
            <strong>Note:</strong> If you have not done so already, I recommend you read the article on
            <NavLink class="[ underline ]" href="blogs/single-responsibility-principle-in-solid" Match="NavLinkMatch.All">Single Responsibility Principle in SOLID</NavLink>.
        </p>

        <h3 class="[ font-semibold text-lg ]">Table of Contents</h3>
        
        <ol class="[ list-decimal ] [ ml-4 ]">
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#introduction")" Match="NavLinkMatch.All">
                    Introduction
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#when-to-apply-ocp")" Match="NavLinkMatch.All">
                    When to apply OCP?
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#demo")" Match="NavLinkMatch.All">
                    Demo
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#advantages")" Match="NavLinkMatch.All">
                    Advantages
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#summary")" Match="NavLinkMatch.All">
                    Summary
                </NavLink>
            </li>
        </ol>

        <h3 id="introduction" class="[ font-semibold text-lg ]">Introduction</h3>
        
        <p>
            The <ContentHighlight>Open Closed Principle (OCP)</ContentHighlight> is a fundamental principle of <ContentHighlight>SOLID</ContentHighlight>. The 
            <ContentHighlight>OCP</ContentHighlight> states that software entities should be <ContentHighlight>open to extension but closed to modification</ContentHighlight>. 
            We all are using OCP principle in DTO's / POCO's without even knowing that we are using it. In API's we send back response to client using DTO. Once clients starts 
            to consume we cannot remove a property from DTO as it might break the clients which means <ContentHighlight>closed for modification</ContentHighlight>. But we add new
            property to DTO to send new data / information to clients which means <ContentHighlight>open for extension</ContentHighlight>.
        </p>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="when-to-apply-ocp" class="[ font-semibold text-lg ]">When to apply OCP?</h3>

        <p>
            The Open Closed Principle should be applied to any <ContentHighlight>software entity that is likely to change over time</ContentHighlight>. This includes classes, 
            methods, and interfaces. When designing software, it is essential to consider the possibility of future changes, and the OCP helps to future-proof our codebase.
        </p>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="demo" class="[ font-semibold text-lg ]">Demo</h3>

        <p>
            Let's take a look at a C# code sample that demonstrates the Open Closed Principle. In this example, we have an interface called <ContentHighlight>IShape</ContentHighlight> 
            that defines a method called <ContentHighlight>Area</ContentHighlight>. We then have two classes, <ContentHighlight>Rectangle</ContentHighlight> and <ContentHighlight>Circle</ContentHighlight>, 
            that implement the <ContentHighlight>IShape</ContentHighlight> <ContentHighlight>interface</ContentHighlight> and provide their implementation of the <ContentHighlight>Area</ContentHighlight> 
            method.
        </p>

        <GithubGistSnippet Title="OCP - Open Closed Principle - Before" UserId="fingers10" FileName="fc1d35392976838eb1c3ec353959f09e"></GithubGistSnippet>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <p>
            Now let's say we need to add a <ContentHighlight>new shape</ContentHighlight> to our system, a <ContentHighlight>Triangle</ContentHighlight>. We can do this 
            without modifying the existing code by creating a <ContentHighlight>new class</ContentHighlight> that implements the <ContentHighlight>IShape interface</ContentHighlight> 
            and provides its implementation of the <ContentHighlight>Area</ContentHighlight> method.
        </p>

        <GithubGistSnippet Title="OCP - Open Closed Principle - After" UserId="fingers10" FileName="0af249355796573658f23903d1efd4bf"></GithubGistSnippet>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <p>
            By following the Open Closed Principle, we were able to extend our system to include a new shape without modifying the existing code. This allows us to avoid 
            introducing bugs and breaking existing functionality.
        </p>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="advantages" class="[ font-semibold text-lg ]">Advantages</h3>

        <p>
            The Open Closed Principle has several advantages, including:
        </p>

        <ul>
            <li><ContentHighlight>Testability</ContentHighlight>: Makes code more testable by reducing the need for regression testing when making changes. This allows for faster and more efficient testing.</li>
            <li><ContentHighlight>Maintainability</ContentHighlight>: Makes code more maintainable by reducing the risk of introducing bugs and breaking existing functionality when making changes.</li>
            <li><ContentHighlight>Reusability</ContentHighlight>: By designing software entities to be open to extension but closed to modification, we can create more reusable code.</li>
            <li><ContentHighlight>Scalability</ContentHighlight>: By allowing software entities to be extended without modifying the existing code, the OCP makes code more scalable and adaptable to changing requirements.</li>
            <li><ContentHighlight>Better Teamwork</ContentHighlight>: Team members can work on different parts of the system simultaneously without interfering with each other's work. This leads to more efficient teamwork and a more efficient development process.</li>
        </ul>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="summary" class="[ font-semibold text-lg ]">Summary</h3>

        <p>
            The <ContentHighlight>Open Closed Principle</ContentHighlight> is an essential principle of object-oriented design that states that software entities should be 
            <ContentHighlight>open to extension but closed to modification</ContentHighlight>. By following this principle, we can ensure that our software is more 
            <ContentHighlight>maintainable, scalable, and adaptable</ContentHighlight> to changing requirements. The use of <ContentHighlight>abstraction</ContentHighlight>, 
            <ContentHighlight>inheritance</ContentHighlight>, and <ContentHighlight>interfaces</ContentHighlight> allows us to extend our software entities without modifying 
            the existing code, reducing the risk of introducing bugs and breaking existing functionality. By following the OCP, we can create more flexible, maintainable, and 
            robust codebases that are easier to test and scale.
        </p>
    </ContentBody>
</Content>

@code {
    private string Description = "In this post I will teach you Open Closed Principle in SOLID Principles in .NET. All with live working demo.";
    private string Slug = "open-closed-principle-in-solid";
    private string PosterPath = "Blogs/SOLID";
    private string Channel = "solid";
    private string ContentType = "blogs";
    private ushort TotalContents => (ushort)tableOfContents.Contents.Count(content => content.Type.Equals("SOLID", StringComparison.CurrentCultureIgnoreCase));
}