@page "/blogs/solid-principles-introduction"
@inherits FragmentNavigationBase
@inject TableOfContents tableOfContents

<Content 
         Description=@Description
         CreatedOn=@CreatedOn
         ModifiedOn=@ModifiedOn
         Slug=@Slug
         PosterPath=@PosterPath
         Keywords=@Keywords
         Channel="@Channel"
         ContentType="@ContentType"
         TotalContents=@TotalContents
         Type="SOLID"
         FileName=@nameof(Introduction)>
    <ContentBody>
        <p>
            In this article, let's learn about <ContentHighlight>SOLID</ContentHighlight> Principles in .NET.
        </p>

        <h3 class="[ font-semibold text-lg ]">Table of Contents</h3>
        
        <ol class="[ list-decimal ] [ ml-4 ]">
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#introduction")" Match="NavLinkMatch.All">
                    Introduction
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#why-solid-principles")" Match="NavLinkMatch.All">
                    Why SOLID Principles?
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#single-responsibility-principle")" Match="NavLinkMatch.All">
                    Single Responsibility Principle
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#open-closed-principle")" Match="NavLinkMatch.All">
                    Open / Closed Principle
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#liskov-substitution-principle")" Match="NavLinkMatch.All">
                    Liskov Substitution Principle
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#interface-segregation-principle")" Match="NavLinkMatch.All">
                    Interface Segregation Principle
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#dependency-inversion-principle")" Match="NavLinkMatch.All">
                    Dependency Inversion Principle
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#summary")" Match="NavLinkMatch.All">
                    Summary
                </NavLink>
            </li>
        </ol>

        <h3 id="introduction" class="[ font-semibold text-lg ]">Introduction</h3>
        
        <p>
            <ContentHighlight>SOLID</ContentHighlight> principles are a set of guidelines that help developers write maintainable and scalable code. These principles were 
            introduced by Robert C. Martin, also known as Uncle Bob, in the early 2000s. The SOLID acronym stands for five principles: 
        </p>

        <ol class="[ list-decimal ] [ ml-4 ]">
            <li><ContentHighlight>Single Responsibility Principle</ContentHighlight></li>
            <li><ContentHighlight>Open/Closed Principle</ContentHighlight></li>
            <li><ContentHighlight>Liskov Substitution Principle</ContentHighlight></li>
            <li><ContentHighlight>Interface Segregation Principle</ContentHighlight></li>
            <li><ContentHighlight>Dependency Inversion Principle</ContentHighlight></li>
        </ol>

        <p>
            In this article, we will explore each principle and its importance in building robust software applications, with practical examples in C#.
        </p>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="why-solid-principles" class="[ font-semibold text-lg ]">Why SOLID Principles?</h3>

        <p>
            Here are some of the benefits of using SOLID principles in software development:
        </p>

        <dl>
            <dt><ContentHighlight>Maintainability</ContentHighlight></dt>
            <dd>
                SOLID principles help developers write code that is easier to understand and modify, reducing the risk of introducing errors or bugs. This can save time and 
                effort when it comes to maintaining and updating the software over its lifetime.
            </dd>
            <dt><ContentHighlight>Scalability</ContentHighlight></dt>
            <dd>
                SOLID principles provide a framework for building software systems that can grow and adapt to changing requirements and environments, without sacrificing 
                stability or performance.
            </dd>
            <dt><ContentHighlight>Flexibility</ContentHighlight></dt>
            <dd>
                SOLID principles encourage code that is modular, loosely coupled, and easy to reuse, making it easier to add new features or functionality to the software as 
                needed.
            </dd>
            <dt><ContentHighlight>Testability</ContentHighlight></dt>
            <dd>
                SOLID principles promote code that is easier to test, reducing the likelihood of introducing bugs and increasing the confidence and reliability of the 
                tests.
            </dd>
        </dl>

        <p>
            Overall, using SOLID principles can help developers create software that is easier to build, test, maintain, and extend, leading to better quality software and 
            more satisfied users.
        </p>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="single-responsibility-principle" class="[ font-semibold text-lg ]">Single Responsibility Principle</h3>
        
        <p>
            The first principle is the <ContentHighlight>Single Responsibility Principle (SRP)</ContentHighlight>. It states that a class should have only one reason to 
            change. In other words, a class should have <ContentHighlight>only one responsibility</ContentHighlight> or job. This principle helps to keep the codebase 
            maintainable and easy to understand. Let's take an example in C#. Suppose we have a <ContentHighlight>class</ContentHighlight> called <ContentHighlight>Customer</ContentHighlight> 
            that has two responsibilities: <ContentHighlight>managing customer data</ContentHighlight> and <ContentHighlight>sending emails</ContentHighlight> to customers. 
            To apply SRP, we can create two classes, <ContentHighlight>Customer</ContentHighlight> and <ContentHighlight>EmailSender</ContentHighlight>, where each class has a 
            single responsibility.
        </p>

        <GithubGistSnippet Title="SRP - Single Responsibility Principle" UserId="fingers10" FileName="3a4452d203b6da084460e6ddcc28f934"></GithubGistSnippet>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="open-closed-principle" class="[ font-semibold text-lg ]">Open / Closed Principle</h3>

        <p>
            The second principle is the <ContentHighlight>Open/Closed Principle (OCP)</ContentHighlight>. It states that a class should be open for extension but closed for 
            modification. In other words, we should be able to <ContentHighlight>extend the behavior of a class without changing its source code</ContentHighlight>. This 
            principle helps to prevent code changes that can break existing functionality. Let's take an example in C#. Suppose we have a <ContentHighlight>class</ContentHighlight> 
            called <ContentHighlight>PaymentProcessor</ContentHighlight> that processes payments. To apply OCP, we can create an <ContentHighlight>interface</ContentHighlight> called 
            <ContentHighlight>IPaymentProcessor</ContentHighlight> and implement it in <ContentHighlight>PaymentProcessor</ContentHighlight>. Then, we can create a <ContentHighlight>new class</ContentHighlight> 
            called <ContentHighlight>PayPalPaymentProcessor</ContentHighlight> that implements the <ContentHighlight>IPaymentProcessor interface</ContentHighlight>, and we can extend 
            the behavior of <ContentHighlight>PaymentProcessor</ContentHighlight> without changing its source code.
        </p>

        <GithubGistSnippet Title="OCP - Open / Closed Principle" UserId="fingers10" FileName="78761ba0cc47c57d3dac0327d3e19016"></GithubGistSnippet>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="liskov-substitution-principle" class="[ font-semibold text-lg ]">Liskov Substitution Principle</h3>

        <p>
            The third principle is the <ContentHighlight>Liskov Substitution Principle (LSP)</ContentHighlight>. It states that objects of a superclass should be replaceable 
            with objects of a subclass without affecting the correctness of the program. In other words, <ContentHighlight>a subclass should behave like its superclass</ContentHighlight>. 
            This principle helps to ensure that the codebase is easy to maintain and understand. Let's take an example in C#. Suppose we have a <ContentHighlight>class</ContentHighlight> 
            called <ContentHighlight>Animal</ContentHighlight> and two subclasses called <ContentHighlight>Dog</ContentHighlight> and <ContentHighlight>Cat</ContentHighlight>. 
            <ContentHighlight>Animal</ContentHighlight> has a method called <ContentHighlight>MakeSound()</ContentHighlight>. To apply LSP, we should be able to call <ContentHighlight>MakeSound()</ContentHighlight> 
            on both <ContentHighlight>Dog</ContentHighlight> and <ContentHighlight>Cat</ContentHighlight>, and they should behave like an <ContentHighlight>Animal</ContentHighlight>.
        </p>

        <GithubGistSnippet Title="LSP - Liskov Substitution Principle" UserId="fingers10" FileName="0ec2697dec2db1598b8a88f2a55c0a6d"></GithubGistSnippet>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="interface-segregation-principle" class="[ font-semibold text-lg ]">Interface Segregation Principle</h3>

        <p>
            The fourth principle is the <ContentHighlight>Interface Segregation Principle (ISP)</ContentHighlight>. It states that a client should not be forced to depend on 
            methods it does not use. In other words, <ContentHighlight>an interface should be focused on a specific set of behaviors</ContentHighlight>. This principle helps 
            to keep the codebase modular and easy to maintain. Let's take an example in C#. Suppose we have an <ContentHighlight>interface</ContentHighlight> called 
            <ContentHighlight>ICustomer</ContentHighlight> that has two methods: <ContentHighlight>Add()</ContentHighlight> and <ContentHighlight>Delete()</ContentHighlight>. 
            To apply ISP, we can create two interfaces, <ContentHighlight>IAddCustomer</ContentHighlight> and <ContentHighlight>IDeleteCustomer</ContentHighlight>, where each 
            <ContentHighlight>interface</ContentHighlight> has a single method.
        </p>

        <GithubGistSnippet Title="ISP - Interface Segregation Principle" UserId="fingers10" FileName="6e36440c2f16020a57f28bf64c9fe7d4"></GithubGistSnippet>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="dependency-inversion-principle" class="[ font-semibold text-lg ]">Dependency Inversion Principle</h3>

        <p>
            The fifth principle is the <ContentHighlight>Dependency Inversion Principle (DIP)</ContentHighlight>. It states that <ContentHighlight>high-level modules should 
            not depend on low-level modules. Instead, they should depend on abstractions</ContentHighlight>. This principle helps to keep the codebase flexible and easy to 
            maintain. Let's take an example in C#. Suppose we have a <ContentHighlight>class</ContentHighlight> called <ContentHighlight>OrderProcessor</ContentHighlight> that 
            depends on a class called <ContentHighlight>PaymentProcessor</ContentHighlight>. To apply DIP, we can create an <ContentHighlight>interface</ContentHighlight> called 
            <ContentHighlight>IPaymentProcessor</ContentHighlight> and <ContentHighlight>inject</ContentHighlight> it into <ContentHighlight>OrderProcessor</ContentHighlight>. Then, 
            we can create a new class called <ContentHighlight>PayPalPaymentProcessor</ContentHighlight> that implements the <ContentHighlight>IPaymentProcessor interface</ContentHighlight>, 
            and we can <ContentHighlight>inject</ContentHighlight> it into <ContentHighlight>OrderProcessor</ContentHighlight>.
        </p>

        <GithubGistSnippet Title="DIP - Dependency Inversion Principle" UserId="fingers10" FileName="070e36ba95bb5228fcd464bc80d0cd32"></GithubGistSnippet>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="summary" class="[ font-semibold text-lg ]">Summary</h3>

        <p>
            In this article we learn't what is <ContentHighlight>SOLID</ContentHighlight> principles. In conclusion, SOLID principles are essential guidelines that help 
            developers write <ContentHighlight>maintainable and scalable</ContentHighlight> code. By following these principles, we can build robust software applications 
            that are easy to <ContentHighlight>understand, maintain, and extend</ContentHighlight>. In this article, we have explored each principle and provided practical 
            examples in C#. Lets learn more about each principle in detail in upcoming articles.
        </p>
    </ContentBody>
</Content>

@code {
    private string Description = "In this post I will introduce you to SOLID Principles in .NET. All with live working demo.";
    private DateTime CreatedOn = new DateTime(2023, 4, 2, 22, 30, 0);
    private DateTime ModifiedOn = new DateTime(2023, 4, 2, 22, 30, 0);
    private string Slug = "solid-principles-introduction";
    private string PosterPath = "Blogs/SOLID";
    private string Channel = "solid";
    private string ContentType = "blogs";
    private ushort TotalContents => (ushort)tableOfContents.Contents.Count(content => content.Type.Equals("SOLID", StringComparison.CurrentCultureIgnoreCase));
    private List<string> Keywords = new(5) { "SRP", "OCP", "LSP", "ISP", "DIP" };
}