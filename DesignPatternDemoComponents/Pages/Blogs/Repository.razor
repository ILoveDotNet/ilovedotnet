@page "/blogs/enterprise-design-pattern-repository"
@using DesignPatternDemoComponents.Repository
@inherits BasePage

<Content FileName=@nameof(Repository)>
    <ContentBody>
        <p>
            In this article, let's learn about <ContentHighlight>Repository Design Pattern</ContentHighlight> in .NET.
        </p>

        <h3 class="[ font-semibold text-lg ]">Table of Contents</h3>
        
        <ol class="[ list-decimal ] [ ml-4 ]">
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#introduction")" Match="NavLinkMatch.All">
                    Introduction
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#what-is-repository-pattern")" Match="NavLinkMatch.All">
                    What is Repository Pattern?
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#implementing-a-repository-pattern")" Match="NavLinkMatch.All">
                    Implementing a Repository Pattern
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#generic-repository")" Match="NavLinkMatch.All">
                    Generic Repository
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#non-generic-repository")" Match="NavLinkMatch.All">
                    Non Generic Repository
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#combining-generic-and-non-generic-repository")" Match="NavLinkMatch.All">
                    Combining Generic and Non Generic Repository
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#faqs")" Match="NavLinkMatch.All">
                    FAQs
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#summary")" Match="NavLinkMatch.All">
                    Summary
                </NavLink>
            </li>
        </ol>

        <h3 id="introduction" class="[ font-semibold text-lg ]">Introduction</h3>
        
        <p>
            The Repository pattern is a commonly used enterprise design pattern, especially in enterprise applications. It helps to abstract and encapsulate 
            data access logic, promoting a clean separation of concerns between business logic and data access logic.
        </p>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="what-is-repository-pattern" class="[ font-semibold text-lg ]">What is Repository Pattern?</h3>
        
        <p>
            The Repository pattern provides a way to manage data access with minimal code duplication and improved testability. It abstracts the data layer, 
            making the business logic unaware of the underlying data source. This allows developers to switch persistence technologies, if needed, without 
            impacting the business logic. Repository Pattern in other words allows developer to have a specific persistence for each repository based on need.
        </p>

        <p>
            Instead of directly interacting with the database using tools like ADO.NET or Entity Framework Core, the business logic communicates with repositories. 
            These repositories provide a set of methods to perform CRUD (Create, Read, Update, Delete) operations on data entities.
        </p>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="implementing-a-repository-pattern" class="[ font-semibold text-lg ]">Implementing Repository Pattern</h3>

        <p>
            A typical repository starts with a contract, often defined as an interface. This interface defines common data operations that can be reused across 
            different entities, reducing redundancy in your codebase. For example:
        </p>

        <GithubGistSnippet Title="Generic Repository" UserId="fingers10" FileName="79c1bee78f117e2b3545a0dbe67e8a50"></GithubGistSnippet>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="generic-repository" class="[ font-semibold text-lg ]">Generic Repository</h3>

        <p>
            A generic repository allows you to define common CRUD operations once and reuse them across multiple entities, reducing code duplication. In this 
            example, lets take EF Core as the ORM and define a generic repository that implements the IRepository interface.
        </p>

        <GithubGistSnippet Title="Generic Repository Implementation" UserId="fingers10" FileName="7ec7256718d7776fc3c45861b0cf89d8"></GithubGistSnippet>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

       <h4 class="[ font-semibold text-base ]">Advantages</h4>

        <ul class="[ list-disc ] [ ml-4 ]">
            <li>Reusability: Common data operations are defined once and reused across multiple entities.</li>
            <li>Consistency: All entities have a consistent API for CRUD operations.</li>
        </ul>

       <h4 class="[ font-semibold text-base ]">Disadvantages</h4>

        <ul class="[ list-disc ] [ ml-4 ]">
            <li>Lack of Specificity: May not provide methods tailored to specific entities, requiring additional custom methods.</li>
            <li>Over-generalization: Can become too abstract, making it difficult to implement entity-specific logic.</li>
        </ul>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="non-generic-repository" class="[ font-semibold text-lg ]">Non Generic Repository</h3>

        <p>
            Non-generic repositories are tailored to specific entities. They define custom methods that are unique to the entity they represent. But also have 
            the same methods defined in the generic repository. For example:
        </p>

        <GithubGistSnippet Title="Non Generic Repository" UserId="fingers10" FileName="281d18a3fc9ac054e295f0459f6eb931"></GithubGistSnippet>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

       <h4 class="[ font-semibold text-base ]">Advantages</h4>

        <ul class="[ list-disc ] [ ml-4 ]">
            <li>Specificity: Tailored to the needs of specific entities, making them more flexible for complex queries and operations.</li>
            <li>Clear Intent: The repository's purpose is clear, as it deals with a specific entity.</li>
        </ul>

       <h4 class="[ font-semibold text-base ]">Disadvantages</h4>

        <ul class="[ list-disc ] [ ml-4 ]">
            <li>Potential Code Duplication: Common CRUD operations may be repeated across different repositories.</li>
            <li>Maintenance Overhead: Managing multiple repositories can become cumbersome in large projects.</li>
        </ul>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="combining-generic-and-non-generic-repository" class="[ font-semibold text-lg ]">Combining Generic and Non Generic Repository</h3>

        <p>
            In practice, you can mix both approaches. Use a generic repository for common operations and a non-generic repository for entity-specific methods. 
            All we need to do is to create a non-generic repository that inherits from the generic repository and implements the entity-specific methods. This 
            way, we can reuse the common CRUD operations defined in the generic repository and add custom methods as needed reducing massive code duplication.
        </p>

        <GithubGistSnippet Title="Combining Generic and Non Generic Repository" UserId="fingers10" FileName="fd5a0543f86545b864d7b4bcd71f9693"></GithubGistSnippet>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <GithubGistSnippet Title="Combining Generic and Non Generic Repository Implementation" UserId="fingers10" FileName="034fe3e75512edad14f5c604895f70c5"></GithubGistSnippet>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="faqs" class="[ font-semibold text-lg ]">FAQs</h3>

       <h4 class="[ font-semibold text-base ]">Entity Framework Core and the Repository Pattern</h4>

        <p>
            Entity Framework Core (EF Core) can be used with the Repository pattern to simplify data access. While EF Core provides a built-in repository pattern, 
            you can choose whether to use it directly or implement your own.
        </p>

       <h4 class="[ font-semibold text-base ]">Should You Use EF Core's Built-In Repository?</h4>

        <p>
            Entity Framework Core provides a repository implementation via the DbSet. But it is considered a bit leaky, so it's often encapsulated in another 
            repository just as we did in the demos.
        </p>

       <h4 class="[ font-semibold text-base ]">Multiple SaveChangesAsync()?</h4>

        <p>
            The problem with multiple SaveChangesAsync() calls in each respository is that they can lead to inconsistent data states. To avoid this, consider 
            using a Unit of Work pattern to manage transactions across repositories which we will cover in next article.
        </p>
        
        <h3 id="summary" class="[ font-semibold text-lg ]">Summary</h3>

        <p>
            The Repository pattern, whether generic, non-generic, or a combination, is a powerful tool for managing data access in a clean, maintainable way. 
            It enhances testability, flexibility, and maintainability, allowing your application to adapt as requirements change. But, we've currently got those 
            SaveChanges called in our repositories, does such a method really belong there? And what if we need to work with transactions across repositories? 
            That is where the Unit of Work pattern comes in. Let's have a look at that one next.
        </p>
    </ContentBody>
</Content>