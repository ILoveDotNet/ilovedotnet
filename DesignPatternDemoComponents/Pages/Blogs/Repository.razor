@page "/blogs/enterprise-design-pattern-repository"
@using DesignPatternDemoComponents.Repository
@inherits BasePage

<Content FileName=@nameof(Repository)>
    <ContentBody>
        <p>
            In this article, let's learn about <ContentHighlight>Repository Design Pattern</ContentHighlight> in .NET.
        </p>

        <h3 class="[ font-semibold text-lg ]">Table of Contents</h3>
        
        <ol class="[ list-decimal ] [ ml-4 ]">
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#introduction")" Match="NavLinkMatch.All">
                    Introduction
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#what-is-repository-pattern")" Match="NavLinkMatch.All">
                    What is Repository Pattern?
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#implementing-a-repository-pattern")" Match="NavLinkMatch.All">
                    Implementing a Repository Pattern
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#generic-repository")" Match="NavLinkMatch.All">
                    Generic Repository
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#non-generic-repository")" Match="NavLinkMatch.All">
                    Non Generic Repository
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#combining-generic-and-non-generic-repository")" Match="NavLinkMatch.All">
                    Combining Generic and Non Generic Repository
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#faqs")" Match="NavLinkMatch.All">
                    FAQs
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#summary")" Match="NavLinkMatch.All">
                    Summary
                </NavLink>
            </li>
        </ol>

        <h3 id="introduction" class="[ font-semibold text-lg ]">Introduction</h3>
        
        <p>
            The <ContentHighlight>Repository pattern</ContentHighlight> is a commonly used <ContentHighlight>enterprise design pattern</ContentHighlight>, 
            especially in enterprise applications. It helps to <ContentHighlight>abstract and encapsulate data access</ContentHighlight> logic, promoting a 
            clean separation of concerns between business logic and data access logic.
        </p>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="what-is-repository-pattern" class="[ font-semibold text-lg ]">What is Repository Pattern?</h3>
        
        <p>
            The Repository pattern provides a way to manage data access with <ContentHighlight>minimal code duplication</ContentHighlight> and 
            <ContentHighlight>improved testability</ContentHighlight>. It abstracts the data layer, making the business logic unaware of the underlying data 
            source. This allows developers to switch persistence technologies, if needed, without impacting the business logic. Repository Pattern in other 
            words allows developer to have a <ContentHighlight>specific persistence</ContentHighlight> for each repository based on need.
        </p>

        <p>
            Instead of directly interacting with the database using tools like ADO.NET or Entity Framework Core, the business logic communicates with repositories. 
            These repositories provide a set of methods to perform CRUD (Create, Read, Update, Delete) operations on data entities.
        </p>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="implementing-a-repository-pattern" class="[ font-semibold text-lg ]">Implementing Repository Pattern</h3>

        <p>
            A typical repository starts with a contract, often defined as an <ContentHighlight>interface</ContentHighlight>. This 
            <ContentHighlight>interface</ContentHighlight> defines common data operations that can be reused across different entities, reducing redundancy 
            in your codebase. For example:
        </p>

        <GithubGistSnippet Title="Generic Repository" UserId="fingers10" FileName="79c1bee78f117e2b3545a0dbe67e8a50"></GithubGistSnippet>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="generic-repository" class="[ font-semibold text-lg ]">Generic Repository</h3>

        <p>
            A <ContentHighlight>generic repository</ContentHighlight> allows you to define <ContentHighlight>common</ContentHighlight> CRUD operations once and 
            <ContentHighlight>reuse</ContentHighlight> them across multiple entities, <ContentHighlight>reducing code duplication</ContentHighlight>. In this 
            example, lets take EF Core as the ORM and define a generic repository that implements the <ContentHighlight>IRepository interface</ContentHighlight>.
        </p>

        <GithubGistSnippet Title="Generic Repository Implementation" UserId="fingers10" FileName="7ec7256718d7776fc3c45861b0cf89d8"></GithubGistSnippet>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

       <h4 class="[ font-semibold text-base ]">Advantages</h4>

        <ul class="[ list-disc ] [ ml-4 ]">
            <li><ContentHighlight>Reusability</ContentHighlight>: Common data operations are defined once and reused across multiple entities.</li>
            <li><ContentHighlight>Consistency</ContentHighlight>: All entities have a consistent API for CRUD operations.</li>
        </ul>

       <h4 class="[ font-semibold text-base ]">Disadvantages</h4>

        <ul class="[ list-disc ] [ ml-4 ]">
            <li><ContentHighlight>Lack of Specificity</ContentHighlight>: May not provide methods tailored to specific entities, requiring additional custom methods.</li>
            <li><ContentHighlight>Over-generalization</ContentHighlight>: Can become too abstract, making it difficult to implement entity-specific logic.</li>
        </ul>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="non-generic-repository" class="[ font-semibold text-lg ]">Non Generic Repository</h3>

        <p>
            <ContentHighlight>Non-generic repositories</ContentHighlight> are tailored to specific entities. They define <ContentHighlight>custom</ContentHighlight> 
            methods that are unique to the entity they represent. But also have the <ContentHighlight>same methods defined in the generic repository</ContentHighlight>. 
            For example:
        </p>

        <GithubGistSnippet Title="Non Generic Repository" UserId="fingers10" FileName="281d18a3fc9ac054e295f0459f6eb931"></GithubGistSnippet>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

       <h4 class="[ font-semibold text-base ]">Advantages</h4>

        <ul class="[ list-disc ] [ ml-4 ]">
            <li><ContentHighlight>Specificity</ContentHighlight>: Tailored to the needs of specific entities, making them more flexible for complex queries and operations.</li>
            <li><ContentHighlight>Clear Intent</ContentHighlight>: The repository's purpose is clear, as it deals with a specific entity.</li>
        </ul>

       <h4 class="[ font-semibold text-base ]">Disadvantages</h4>

        <ul class="[ list-disc ] [ ml-4 ]">
            <li><ContentHighlight>Potential Code Duplication</ContentHighlight>: Common CRUD operations may be repeated across different repositories.</li>
            <li><ContentHighlight>Maintenance Overhead</ContentHighlight>: Managing multiple repositories can become cumbersome in large projects.</li>
        </ul>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="combining-generic-and-non-generic-repository" class="[ font-semibold text-lg ]">Combining Generic and Non Generic Repository</h3>

        <p>
            In practice, you can <ContentHighlight>mix both approaches</ContentHighlight>. Use a <ContentHighlight>generic repository</ContentHighlight> for 
            <ContentHighlight>common operations</ContentHighlight> and a <ContentHighlight>non-generic</ContentHighlight> repository for 
            <ContentHighlight>entity-specific</ContentHighlight> methods. All we need to do is to create a <ContentHighlight>non-generic repository that inherits 
            from the generic repository and implements the entity-specific methods</ContentHighlight>. This way, we can reuse the common CRUD operations 
            defined in the generic repository and add custom methods as needed reducing massive code duplication.
        </p>

        <GithubGistSnippet Title="Combining Generic and Non Generic Repository" UserId="fingers10" FileName="fd5a0543f86545b864d7b4bcd71f9693"></GithubGistSnippet>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <GithubGistSnippet Title="Combining Generic and Non Generic Repository Implementation" UserId="fingers10" FileName="034fe3e75512edad14f5c604895f70c5"></GithubGistSnippet>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="faqs" class="[ font-semibold text-lg ]">FAQs</h3>

       <h4 class="[ font-semibold text-base ]">Entity Framework Core and the Repository Pattern</h4>

        <p>
            <ContentHighlight>Entity Framework Core (EF Core)</ContentHighlight> can be used with the Repository pattern to simplify data access. While 
            EF Core provides a built-in repository pattern, you can choose whether to use it directly or implement your own.
        </p>

       <h4 class="[ font-semibold text-base ]">Should You Use EF Core's Built-In Repository?</h4>

        <p>
            <ContentHighlight>Entity Framework Core</ContentHighlight> provides a repository implementation via the <ContentHighlight>DbSet</ContentHighlight>. 
            But it is considered a bit <ContentHighlight>leaky</ContentHighlight>, so it's often <ContentHighlight>encapsulated</ContentHighlight> in another 
            repository just as we did in the demos.
        </p>

       <h4 class="[ font-semibold text-base ]">Multiple SaveChangesAsync()?</h4>

        <p>
            The problem with multiple <ContentHighlight>SaveChangesAsync()</ContentHighlight> calls in each respository is that they can lead to 
            <ContentHighlight>inconsistent data states</ContentHighlight>. To avoid this, consider using a <ContentHighlight>Unit of Work</ContentHighlight> 
            pattern to <ContentHighlight>manage transactions</ContentHighlight> across repositories which we will cover in next article.
        </p>
        
        <h3 id="summary" class="[ font-semibold text-lg ]">Summary</h3>

        <p>
            The <ContentHighlight>Repository</ContentHighlight> pattern, whether <ContentHighlight>generic</ContentHighlight>, 
            <ContentHighlight>non-generic</ContentHighlight>, or a <ContentHighlight>combination</ContentHighlight>, is a powerful tool for managing data access in a 
            <ContentHighlight>clean, maintainable</ContentHighlight> way. It enhances <ContentHighlight>testability, flexibility, and maintainability</ContentHighlight>, 
            allowing your application to adapt as requirements change. But, we've currently got those <ContentHighlight>SaveChanges</ContentHighlight> called in 
            our repositories, does such a method really belong there? And what if we need to work with <ContentHighlight>transactions</ContentHighlight> across 
            repositories? That is where the Unit of Work pattern comes in. Let's have a look at that one next.
        </p>
    </ContentBody>
</Content>