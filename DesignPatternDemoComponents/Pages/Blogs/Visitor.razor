@page "/blogs/behavioral-design-pattern-visitor"
@using DesignPatternDemoComponents.Visitor
@inherits BasePage

<Content FileName=@nameof(Visitor) UseNewTableOfContentsMenu=true>
  <ContentBody>
    <What>
      <p>
        The Visitor pattern is a behavioral design pattern that represents an operation performed on elements of an
        object structure. It allows adding new operations without altering the existing classes of these elements. For
        example, in an Amazon order system, FreeUser pays a ₹40 delivery cost, while PrimeUser has zero delivery cost.
        The Visitor pattern helps apply such behavior changes flexibly across different user types.
      </p>
    </What>

    <Why>
      <p>
        The Visitor pattern is used when:
      </p>

      <ul>
        <li>Object structures contain multiple classes with distinct interfaces.</li>
        <li>New operations need to be added frequently without altering the existing structure.</li>
        <li>You want to avoid violating the Single Responsibility Principle by not mixing unrelated behaviors into one
          class.</li>
        <li>Accumulating information or performing distinct operations across different object types is required.</li>
      </ul>

      <p>
        Benefits:
      </p>

      <ol>
        <li><strong>Open/Closed Principle:</strong> New operations can be added without modifying existing classes.</li>
        <li><strong>Single Responsibility Principle:</strong> Separates behaviors from object structures.</li>
        <li><strong>Flexibility:</strong> Allows adding new operations without altering existing classes.</li>
      </ol>

      <p>
        Example Scenario: In Amazon, shipping costs differ for FreeUsers and PrimeUsers. Instead of modifying user
        classes every time shipping logic changes, use the Visitor Pattern.
      </p>
    </Why>

    <How>
      <h4>Structure</h4>

      <p>
        The Visitor pattern consists of:
      </p>

      <ul>
        <li><strong>Element Interface</strong>: Declares an <code>Accept</code> method to accept a visitor.</li>
        <li><strong>Concrete Elements</strong>: Classes like FreeUser and PrimeUser that implement the element
          interface.</li>
        <li><strong>Visitor Interface</strong>: Declares methods to visit each concrete element.</li>
        <li><strong>Concrete Visitor</strong>: Implements visitor methods (e.g., calculates delivery cost).</li>
        <li><strong>Object Structure</strong>: Manages elements and allows visitor traversal.</li>
      </ul>

      <h4>Implementation</h4>

      <p>
        Example: Delivery Cost Calculation
      </p>

      <ul>
        <li><strong>Elements:</strong> FreeUser (₹40 cost) and PrimeUser (₹0 cost).</li>
        <li><strong>Visitor:</strong> DeliveryCostVisitor calculates and assigns costs.</li>
        <li><strong>Object Structure:</strong> A container holds users and applies the visitor to calculate costs.</li>
      </ul>

      <p>
        Steps:
      </p>

      <ol>
        <li>Define an <code>IElement</code> interface with an <code>Accept</code> method.</li>
        <li>Create <code>FreeUser</code> and <code>PrimeUser</code> implementing <code>IElement</code>.</li>
        <li>Define an <code>IVisitor</code> interface with <code>VisitFreeUser</code> and <code>VisitPrimeUser</code>.
        </li>
        <li>Implement a <code>DeliveryCostVisitor</code> to calculate costs.</li>
        <li>Create a container to hold users and apply the visitor.</li>
      </ol>

      <h4>Simplified Interface</h4>

      <p>
        The visitor interface can have a single <code>Visit</code> method accepting a general element interface. This
        reduces the need for updates when new elements are added but requires type checking within the visitor.
      </p>
    </How>

    <Summary>
      <p>
        The Visitor pattern separates behaviors from object structures, adhering to the Open/Closed and Single
        Responsibility principles. It simplifies adding operations like delivery cost calculations (e.g., ₹40 for
        FreeUser, ₹0 for PrimeUser) but can introduce complexity when new elements are added or when accessing private
        data. Related patterns include Composite (manages object structures) and Iterator (traverses structures while
        applying logic).
      </p>
    </Summary>
  </ContentBody>
</Content>