@page "/blogs/structural-design-pattern-facade"
@using DesignPatternDemoComponents.Facade
@inherits BasePage

<Content FileName=@nameof(Facade)>
    <ContentBody>
        <p>
            In this article, let's learn about <ContentHighlight>Facade Design Pattern</ContentHighlight> in .NET.
        </p>

        <h3 class="[ font-semibold text-lg ]">Table of Contents</h3>
        
        <ol class="[ list-decimal ] [ ml-4 ]">
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#introduction")" Match="NavLinkMatch.All">
                    Introduction
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#structure")" Match="NavLinkMatch.All">
                    Structure
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#use-cases")" Match="NavLinkMatch.All">
                    Use Cases
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#advantages")" Match="NavLinkMatch.All">
                    Advantages
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#disadvantages")" Match="NavLinkMatch.All">
                    Disadvantages
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#related-patterns")" Match="NavLinkMatch.All">
                    Related Patterns
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#summary")" Match="NavLinkMatch.All">
                    Summary
                </NavLink>
            </li>
        </ol>

        <h3 id="introduction" class="[ font-semibold text-lg ]">Introduction</h3>
        
        <p>
            The <ContentHighlight>Facade</ContentHighlight> pattern, a stalwart from the Gang of Four design patterns, serves as a 
            <ContentHighlight>unified interface</ContentHighlight> to a <ContentHighlight>subsystem</ContentHighlight>, simplifying its usage. Imagine a world 
            where operating an entertainment system involves intricate stepsâ€”enter the Facade pattern. In this blog, we'll explore its real-life application 
            through a entertainment service, delve into its structure, uncover its use cases, weigh its advantages and disadvantages, touch upon related patterns, 
            and conclude with a concise summary.
        </p>

        

        <h3 id="structure" class="[ font-semibold text-lg ]">Structure</h3>
        
        <p>
            The Facade pattern, <ContentHighlight>encapsulated</ContentHighlight> in a facade (like our "entertainment facade"), orchestrates subsystem 
            classes <ContentHighlight>DvdPlayer</ContentHighlight>, <ContentHighlight>Sound System</ContentHighlight>, and 
            <ContentHighlight>Projector</ContentHighlight> service. The facade shields clients from the complexities, acting as a gateway to the subsystem, 
            promoting an <ContentHighlight>organized and manageable</ContentHighlight> structure.
        </p>

        

        <GithubGistSnippet Title="Code Sample - Facade Pattern" UserId="fingers10" FileName="17e37fa5e5ad6f0dbe533dd67453539e"></GithubGistSnippet>

        

        <p>
            In the above code snippet, Subsystem Classes <ContentHighlight>DvdPlayer</ContentHighlight>, <ContentHighlight>SoundSystem</ContentHighlight>, and 
            <ContentHighlight>Projector</ContentHighlight> represent individual components of the home entertainment system. Facade Class 
            <ContentHighlight>EntertainmentFacade class</ContentHighlight> acts as a facade, providing simplified methods 
            <ContentHighlight>TurnOnEntertainmentSystem</ContentHighlight> and <ContentHighlight>TurnOffEntertainmentSystem</ContentHighlight>. These methods 
            internally manage the individual components, <ContentHighlight>abstracting</ContentHighlight> away their complexities. Client Code 
            <ContentHighlight>Program</ContentHighlight> creates an instance of <ContentHighlight>EntertainmentFacade</ContentHighlight> and uses its methods to 
            turn on and off the entire entertainment system. The client is shielded from the details of interacting with each subsystem separately. This example 
            demonstrates how the Facade pattern can simplify the usage of a complex system, making it easy for clients to perform common tasks without dealing 
            with the intricacies of individual components.
        </p>

        

        <DemoSnippet Title="Facade Pattern Demo">
            <p>
                Let's try <ContentHighlight>Facade</ContentHighlight> Demo, Click on the <ContentHighlight>Use Entertainment System via Facade</ContentHighlight> 
                Button to see the demo on the screen. Click the button starts the Entertainment system and streams the movie and shuts down the system after 
                the movie is over. For demo purpose the Result is shown in the screen.
            </p>
            <GithubGistSnippet Title="Facade Pattern Demo" UserId="fingers10" FileName="d048fce4a5c0f880dca19070257f2911"></GithubGistSnippet>
            <FacadeDemo></FacadeDemo>
        </DemoSnippet>

        

        <h3 id="use-cases" class="[ font-semibold text-lg ]">Use Cases</h3>

        <ul class="[ list-disc ] [ ml-4 ]">
            <li>
                <ContentHighlight>Simplifying Complexity</ContentHighlight> - When dealing with intricate subsystems, the Facade pattern offers a clean, 
                high-level <ContentHighlight>interface</ContentHighlight>, shielding clients from the nitty-gritty details.
            </li>
            <li>
                <ContentHighlight>Decoupling Dependencies</ContentHighlight> - In scenarios with numerous dependencies between clients and implementation classes, 
                introducing a facade <ContentHighlight>breaks the tight coupling</ContentHighlight>, fostering a more flexible design.
            </li>
            <li>
                <ContentHighlight>Integration with Legacy Systems</ContentHighlight> - Facades prove invaluable when bridging new and legacy systems, 
                <ContentHighlight>abstracting</ContentHighlight> away the intricacies of dealing with legacy code.
            </li>
            <li>
                <ContentHighlight>Content Management Systems</ContentHighlight> - Streamlining operations in systems handling diverse content types, such as 
                articles, images, and videos.
            </li>
            <li>
                <ContentHighlight>Multimedia Playback</ContentHighlight> - <ContentHighlight>Abstracting</ContentHighlight> the complexities of supporting various 
                media formats and providing a unified playback control <ContentHighlight>interface</ContentHighlight>.
            </li>
            <li>
                <ContentHighlight>Payment Processing in E-commerce</ContentHighlight> - Facilitating a unified <ContentHighlight>interface</ContentHighlight> for 
                processing payments, irrespective of the underlying payment gateways.
            </li>
        </ul>

        

        <h3 id="advantages" class="[ font-semibold text-lg ]">Advantages</h3>

        <ul class="[ list-disc ] [ ml-4 ]">
            <li>
                <ContentHighlight>Reduced Client Complexity</ContentHighlight> - Clients interact with a simplified facade, oblivious to the intricate workings of 
                the subsystem.
            </li>
            <li>
                <ContentHighlight>Weak Coupling</ContentHighlight> - Facades promote loose coupling between clients and subsystems, allowing subsystem components 
                to evolve independently.
            </li>
            <li>
                <ContentHighlight>Open-Closed Principle</ContentHighlight> - Clients can easily adapt to changes in subsystem components without modification, 
                adhering to the open-closed principle.
            </li>
        </ul>

        

        <h3 id="disadvantages" class="[ font-semibold text-lg ]">Disadvantages</h3>

        <p>
            <ContentHighlight>Potential Overhead</ContentHighlight> - Introducing facades might add a layer, potentially introducing overhead, especially in 
            simpler systems.
        </p>

        

        <h3 id="related-patterns" class="[ font-semibold text-lg ]">Related Patterns</h3>

        <ul class="[ list-disc ] [ ml-4 ]">
            <li><ContentHighlight>Abstract Factory</ContentHighlight> pattern</li>
            <li><ContentHighlight>Mediator</ContentHighlight> pattern</li>
            <li><ContentHighlight>Adapter</ContentHighlight> pattern</li>
        </ul>

        

        <h3 id="summary" class="[ font-semibold text-lg ]">Summary</h3>

        <p>
            In essence, the <ContentHighlight>Facade</ContentHighlight> pattern <ContentHighlight>simplifies</ContentHighlight> the usage of complex subsystems, 
            providing a clean and <ContentHighlight>unified interface</ContentHighlight>. It excels in scenarios where <ContentHighlight>reducing client 
            complexity</ContentHighlight>, <ContentHighlight>decoupling dependencies</ContentHighlight>, and 
            <ContentHighlight>integrating with legacy systems</ContentHighlight> are paramount. As we wrap up this exploration, keep in mind that the Facade 
            pattern, while powerful, finds its strength in its judicious application alongside other complementary design patterns.
        </p>
    </ContentBody>
</Content>