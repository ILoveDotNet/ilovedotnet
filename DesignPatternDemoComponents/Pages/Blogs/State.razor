@page "/blogs/behavioral-design-pattern-state"
@using DesignPatternDemoComponents.State
@inherits BasePage

<Content FileName=@nameof(State)>
    <ContentBody>
        <p>
            In this article, let's learn about <ContentHighlight>State Design Pattern</ContentHighlight> in .NET.
        </p>

        <h3 class="[ font-semibold text-lg ]">Table of Contents</h3>
        
        <ol class="[ list-decimal ] [ ml-4 ]">
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#introduction")" Match="NavLinkMatch.All">
                    Introduction
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#structure")" Match="NavLinkMatch.All">
                    Structure
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#use-cases")" Match="NavLinkMatch.All">
                    Use Cases
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#advantages")" Match="NavLinkMatch.All">
                    Advantages
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#disadvantages")" Match="NavLinkMatch.All">
                    Disadvantages
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#related-patterns")" Match="NavLinkMatch.All">
                    Related Patterns
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#summary")" Match="NavLinkMatch.All">
                    Summary
                </NavLink>
            </li>
        </ol>

        <h3 id="introduction" class="[ font-semibold text-lg ]">Introduction</h3>
        
        <p>
            The <ContentHighlight>State</ContentHighlight> Pattern is a <ContentHighlight>behavioral</ContentHighlight> design pattern that lets an 
            <ContentHighlight>object</ContentHighlight> alter its behavior when its state changes. Instead of using a large set of 
            <ContentHighlight>if-else</ContentHighlight> or <ContentHighlight>switch</ContentHighlight> statements, 
            <ContentHighlight>state-specific</ContentHighlight> behavior is delegated to separate <ContentHighlight>state classes</ContentHighlight>.
        </p>

        <p>
            For example, consider a <ContentHighlight>bank account</ContentHighlight> that can be in a <ContentHighlight>regular</ContentHighlight> or 
            <ContentHighlight>overdrawn</ContentHighlight> state. Each state has its own rulesâ€”when in an <ContentHighlight>overdrawn state</ContentHighlight>, 
            withdrawals may be restricted. Adding more states, like a <ContentHighlight>gold</ContentHighlight> state for high balances, can make the logic 
            even more complex. Using the state pattern helps to manage this complexity by organizing the behavior in 
            <ContentHighlight>individual classes</ContentHighlight>.
        </p>

        

        <h3 id="structure" class="[ font-semibold text-lg ]">Structure</h3>
        
        <p>
            The <ContentHighlight>State</ContentHighlight> pattern involves several key components:
        </p>

        <ol class="[ list-decimal ] [ ml-4 ]">
            <li>
                <ContentHighlight>Context</ContentHighlight>: The main <ContentHighlight>class</ContentHighlight> that maintains the current state 
                (e.g., <ContentHighlight>BankAccount</ContentHighlight>).
            </li>
            <li>
                <ContentHighlight>State</ContentHighlight>: An <ContentHighlight>abstract base class</ContentHighlight> or 
                <ContentHighlight>interface</ContentHighlight> that defines behaviors for different states 
                (e.g., <ContentHighlight>BankAccountState</ContentHighlight>).
            </li>
            <li>
                <ContentHighlight>Concrete States</ContentHighlight>: Implementations of the state that handle 
                <ContentHighlight>specific state behavior</ContentHighlight> 
                (e.g., <ContentHighlight>RegularState</ContentHighlight>, <ContentHighlight>OverdrawnState</ContentHighlight>).
            </li>
        </ol>

        <GithubGistSnippet Title="State Pattern Code Sample" UserId="fingers10" FileName="42d600ad99e64fc65e1077063df91663"></GithubGistSnippet>

        

        <DemoSnippet Title="State Pattern Demo">
            <p>
                Let's try <ContentHighlight>State</ContentHighlight> Demo, Click on the <ContentHighlight>Deposit</ContentHighlight> 
                button and <ContentHighlight>Withdraw</ContentHighlight> button to see the state pattern in action. 
                The results will be displayed at the bottom.
            </p>
            <GithubGistSnippet Title="State Pattern Demo" UserId="fingers10" FileName="4a34a7643e0bdf2388e30d7d1f18f3ca"></GithubGistSnippet>
            <StateDemo></StateDemo>
        </DemoSnippet>

        <p>
            In the above code, see how state changes automatically based on the balance. When the balance is less than zero, the account is in an 
            <ContentHighlight>Overdrawn</ContentHighlight> state, and withdrawals are restricted. When the balance is greater than zero, the account is in a 
            <ContentHighlight>Regular</ContentHighlight> state, and withdrawals are allowed.
        </p>

        

        <h3 id="use-cases" class="[ font-semibold text-lg ]">Use Cases</h3>

        <p>
            The <ContentHighlight>State</ContentHighlight> pattern is beneficial in several scenarios:
        </p>

        <ol class="[ list-decimal ] [ ml-4 ]">
            <li><ContentHighlight>Document editing</ContentHighlight>: Different modes (insert, overwrite, select) with distinct behaviors.</li>
            <li><ContentHighlight>Vending machine</ContentHighlight>: Different states like idle, selecting, dispensing, and their associated actions.</li>
            <li><ContentHighlight>Workflow management</ContentHighlight>: Tasks change behavior based on whether they are "pending," "in progress," or "completed."</li>
            <li><ContentHighlight>Robotics</ContentHighlight>: Operational modes like "exploration" or "charging" that affect robot behavior.</li>
        </ol>

        

        <h3 id="advantages" class="[ font-semibold text-lg ]">Advantages</h3>

        <ul class="[ list-disc ] [ ml-4 ]">
            <li><ContentHighlight>Positive</ContentHighlight>: Each state-specific behavior is isolated, making it easier to manage transitions and add new states.</li>
        </ul>

        

        <h3 id="disadvantages" class="[ font-semibold text-lg ]">Disadvantages</h3>

        <ul class="[ list-disc ] [ ml-4 ]">
            <li><ContentHighlight>Negative</ContentHighlight>: Adding more states increases the number of classes, leading to more complexity.</li>
        </ul>

        

        <h3 id="related-patterns" class="[ font-semibold text-lg ]">Related Patterns</h3>

        <p>
            The <ContentHighlight>State</ContentHighlight> pattern is closely related to several other design patterns:
        </p>

        <ul class="[ list-disc ] [ ml-4 ]">
            <li><ContentHighlight>Flyweight</ContentHighlight>: State objects can sometimes be shared across contexts, reducing memory usage.</li>
            <li><ContentHighlight>Singleton</ContentHighlight>: Often, state objects can be implemented as singletons since the state is shared.</li>
            <li><ContentHighlight>Strategy</ContentHighlight>: Similar to the state pattern, but strategies don't depend on internal state changes; they are chosen externally.</li>
            <li><ContentHighlight>Bridge</ContentHighlight>: Both patterns share the idea of composition to separate functionality, although they solve different problems.</li>
        </ul>

        

        <h3 id="summary" class="[ font-semibold text-lg ]">Summary</h3>

        <p>
            The <ContentHighlight>State</ContentHighlight> Pattern allows you to manage <ContentHighlight>complex state-dependent behaviors</ContentHighlight> in 
            a clean and scalable way. By <ContentHighlight>encapsulating states</ContentHighlight> in their own <ContentHighlight>classes</ContentHighlight>, 
            you <ContentHighlight>reduce</ContentHighlight> the complexity of <ContentHighlight>conditional logic</ContentHighlight> and make the code 
            <ContentHighlight>easier</ContentHighlight> to <ContentHighlight>extend</ContentHighlight>.
        </p>
    </ContentBody>
</Content>