@page "/blogs/creational-design-pattern-factory"
@using DesignPatternDemoComponents.Factory
@inherits BasePage

<Content FileName=@nameof(Factory)>
    <ContentBody>
        <p>
            In this article, let's learn about <ContentHighlight>Factory Design Pattern</ContentHighlight> in .NET.
        </p>

        <h3>Table of Contents</h3>
        
        <ol>
            <li>
                <NavLink href="@($"blogs/{Slug}#introduction")" Match="NavLinkMatch.All">
                    Introduction
                </NavLink>
            </li>
            <li>
                <NavLink href="@($"blogs/{Slug}#structure")" Match="NavLinkMatch.All">
                    Structure
                </NavLink>
            </li>
            <li>
                <NavLink href="@($"blogs/{Slug}#use-cases")" Match="NavLinkMatch.All">
                    Use Cases
                </NavLink>
            </li>
            <li>
                <NavLink href="@($"blogs/{Slug}#advantages")" Match="NavLinkMatch.All">
                    Advantages
                </NavLink>
            </li>
            <li>
                <NavLink href="@($"blogs/{Slug}#disadvantages")" Match="NavLinkMatch.All">
                    Disadvantages
                </NavLink>
            </li>
            <li>
                <NavLink href="@($"blogs/{Slug}#related-patterns")" Match="NavLinkMatch.All">
                    Related Patterns
                </NavLink>
            </li>
            <li>
                <NavLink href="@($"blogs/{Slug}#summary")" Match="NavLinkMatch.All">
                    Summary
                </NavLink>
            </li>
        </ol>

        <h3 id="introduction">Introduction</h3>
        
        <p>
            The <ContentHighlight>Factory</ContentHighlight> Method is a creational pattern from the famous Gang of Four (GoF) design patterns. Creational 
            patterns focus on object creation, and the factory method is a common approach. Its purpose is to define an <ContentHighlight>interface</ContentHighlight> 
            for <ContentHighlight>object creation</ContentHighlight> while allowing <ContentHighlight>subclasses</ContentHighlight> to determine the 
            <ContentHighlight>actual type of object</ContentHighlight> to instantiate.
        </p>

        <p>
            In essence, the Factory Method allows a <ContentHighlight>class to defer instantiation to subclasses, preventing tight coupling between the client 
            and the specific implementations</ContentHighlight>.
        </p>

        

        <h3 id="structure">Structure</h3>
        
        <p>
            The Factory pattern involves several key components:
        </p>

        <ol>
            <li>
                <ContentHighlight>Creator</ContentHighlight>: Declares the factory method that returns an <ContentHighlight>object</ContentHighlight> of type Product.
            </li>
            <li>
                <ContentHighlight>Concrete Creator</ContentHighlight>: Implements the factory method, returning an <ContentHighlight>instance</ContentHighlight> of a concrete product.
            </li>
            <li>
                <ContentHighlight>Product</ContentHighlight>: An <ContentHighlight>abstract class</ContentHighlight> or <ContentHighlight>interface</ContentHighlight> defining the object to be created.
            </li>
            <li>
                <ContentHighlight>Concrete Product</ContentHighlight>: The actual <ContentHighlight>implementation</ContentHighlight> of the product.
            </li>
        </ol>

        <p>
            Imagine a shopping cart system where different discounts apply based on the user's country or discount code. Instead of the client tightly coupling 
            to different discount services (e.g., <ContentHighlight>CountryDiscountService</ContentHighlight> or <ContentHighlight>CodeDiscountService</ContentHighlight>), 
            we use the Factory Method pattern to <ContentHighlight>abstract the creation process</ContentHighlight>.
        </p>

        <GithubGistSnippet Title="Factory Pattern Code Sample" UserId="fingers10" FileName="8703439c3594229d0a66613fcff3ceec"></GithubGistSnippet>

        

        <DemoSnippet Title="Factory Pattern Demo">
            <p>
                Let's try <ContentHighlight>Factory</ContentHighlight> Demo, Click on the <ContentHighlight>Create Country Discount Service</ContentHighlight> 
                button and <ContentHighlight>Create Code Discount Service</ContentHighlight> button to see the factory pattern in action. 
                The results will be displayed at the bottom.
            </p>
            <GithubGistSnippet Title="Factory Pattern Demo" UserId="fingers10" FileName="02ff16026b10d8b9c7054477989da20a"></GithubGistSnippet>
            <FactoryDemo></FactoryDemo>
        </DemoSnippet>

        <p>
            From the above demo, you can see that how <ContentHighlight>object creation is isolated from the client code</ContentHighlight>. The client only 
            interacts with the <ContentHighlight>abstraction</ContentHighlight>. In real world above <ContentHighlight>Factory Pattern</ContentHighlight> can be 
            used to create different types of objects based on the <ContentHighlight>user country claims</ContentHighlight> or code entered by user to choose 
            the right service to be used in shopping cart.
        </p>

        

        <h3 id="use-cases">Use Cases</h3>

        <p>
            The Factory pattern is beneficial in several scenarios:
        </p>

        <ol>
            <li>
                When a class <ContentHighlight>can't anticipate</ContentHighlight> the class of objects it must create.
            </li>
            <li>
                When a class wants its <ContentHighlight>subclasses to specify the objects</ContentHighlight> it creates.
            </li>
            <li>
                When object creation logic might be <ContentHighlight>complex</ContentHighlight>, and you'd like to <ContentHighlight>encapsulate</ContentHighlight> it in one location.
            </li>
            <li>
                To <ContentHighlight>avoid tight coupling</ContentHighlight> between client code and specific classes.
            </li>
        </ol>

        

        <h3 id="advantages">Advantages</h3>

        <ul>
            <li>
                <ContentHighlight>Loosely couples</ContentHighlight> the client from concrete classes by working with interfaces or abstract classes.
            </li>
            <li>
                Follows the <ContentHighlight>Open/Closed Principle</ContentHighlight>, allowing new product types without modifying existing code.
            </li>
            <li>
                Supports the <ContentHighlight>Single Responsibility Principle</ContentHighlight> by centralizing object creation.
            </li>
        </ul>

        

        <h3 id="disadvantages">Disadvantages</h3>

        <ul>
            <li>
                If you <ContentHighlight>only need one subclass</ContentHighlight>, using the Factory Method might introduce 
                <ContentHighlight>unnecessary complexity</ContentHighlight>.
            </li>
        </ul>

        

        <h3 id="related-patterns">Related Patterns</h3>

        <p>
            The Factory pattern is closely related to several other design patterns:
        </p>

        <ul>
            <li>
                <ContentHighlight>Abstract Factory</ContentHighlight>: Builds on the factory method to create families of related objects.
            </li>
            <li>
                <ContentHighlight>Prototype</ContentHighlight>: Involves cloning objects rather than subclassing for creation.
            </li>
            <li>
                <ContentHighlight>Template Method</ContentHighlight>: Often used in conjunction with Factory Method to handle the logic within the method.
            </li>
        </ul>

        

        <h3 id="summary">Summary</h3>

        <p>
            In this article, we explored the <ContentHighlight>Factory Method pattern</ContentHighlight>, learning how it 
            <ContentHighlight>abstracts object creation by deferring it to subclasses</ContentHighlight>. In our example, we built a 
            discount system where the factory method determines which discount service to instantiate. This pattern 
            <ContentHighlight>prevents tight coupling</ContentHighlight> and adheres to key design principles like <ContentHighlight>Open/Closed</ContentHighlight> 
            and <ContentHighlight>Single</ContentHighlight> Responsibility.
        </p>
    </ContentBody>
</Content>