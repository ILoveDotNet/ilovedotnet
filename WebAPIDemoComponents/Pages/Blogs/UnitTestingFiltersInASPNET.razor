@page "/blogs/unit-testing-filters-in-asp-net-webapi"
@inherits FragmentNavigationBase
@inject TableOfContents tableOfContents

<Content Description=@Description
         Slug=@Slug
         PosterPath=@PosterPath
         Channel="@Channel"
         ContentType="@ContentType"
         TotalContents=@TotalContents
         Type="WebAPI"
         FileName=@nameof(UnitTestingFiltersInASPNET)>
    <ContentBody>
        <p>
            In this article, let's learn about how to unit test <ContentHighlight>Filters</ContentHighlight> in <ContentHighlight>WebAPI</ContentHighlight> in ASP.NET Core.
        </p>

        <h3 class="[ font-semibold text-lg ]">Table of Contents</h3>

        <ol class="[ list-decimal ] [ ml-4 ]">
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#introduction")" Match="NavLinkMatch.All">
                    Introduction
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#why-unit-testing")" Match="NavLinkMatch.All">
                    Why Unit Testing?
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#what-is-a-filter")" Match="NavLinkMatch.All">
                    What is a Filter?
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#types-of-filter")" Match="NavLinkMatch.All">
                    Types of Filter
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#unit-testing-action-filter")" Match="NavLinkMatch.All">
                    Unit Testing Action Filter
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#summary")" Match="NavLinkMatch.All">
                    Summary
                </NavLink>
            </li>
        </ol>

        <h3 id="introduction" class="[ font-semibold text-lg ]">Introduction</h3>

        <p>
            ASP.NET Core filters play a crucial role in the request processing pipeline, allowing code to run before or after specific stages. <ContentHighlight>Filters</ContentHighlight> 
            are utilized to handle cross-cutting concerns, such as <ContentHighlight>authorization</ContentHighlight>, <ContentHighlight>error handling</ContentHighlight>, and 
            <ContentHighlight>caching</ContentHighlight>. Creating custom filters is a common practice to implement unique behaviors and <ContentHighlight>avoid code duplication</ContentHighlight>. 
            Since filters introduce custom behavior, it is essential to test them to ensure their correctness and reliability. In this article, we will focus on unit testing 
            an action filter in ASP.NET Core, exploring the importance of unit testing and providing practical examples for better understanding.
        </p>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="why-unit-testing" class="[ font-semibold text-lg ]">Why Unit Testing ?</h3>

        <p>
            <ContentHighlight>Unit testing</ContentHighlight> is a fundamental practice in software development that involves testing individual components or units of code in 
            isolation to validate their functionality. The benefits of unit testing include:
        </p>

        <ul class="[ ml-4 ] [ list-disc ]">
            <li>Early bug detection</li>
            <li>Improved code quality</li>
            <li>Refactoring safety net</li>
            <li>Documentation</li>
            <li>Confidence in code changes</li>
        </ul>

        <p>
            <strong>Note:</strong> If you have not done so already, I recommend you read the article on
            <NavLink class="[ underline ]" href="blogs/implementing-tdd-in-csharp-dotnet" Match="NavLinkMatch.All">Implementing TDD in C# .Net</NavLink>.
        </p>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="what-is-a-filter" class="[ font-semibold text-lg ]">What is a Filter ?</h3>

        <p>
            In the context of ASP.NET Core, <ContentHighlight>filters</ContentHighlight> are components that <ContentHighlight>execute before or after specific stages in the 
            request processing pipeline</ContentHighlight>. ASP.NET Core provides various built-in filters, such as authorization and response caching filters, and allows 
            developers to create custom filters to address specific requirements.
        </p>

        <h3 id="types-of-filter" class="[ font-semibold text-lg ]">Types of Filter</h3>

        <p>The different types of filters in ASP.NET Core are:</p>

        <ul class="[ ml-4 ] [ list-disc ]">
            <li><ContentHighlight>Action Filters</ContentHighlight>: Run immediately before and after an action method is invoked. They can modify the arguments passed to an action and alter the result returned by an action.</li>
            <li><ContentHighlight>Authorization Filters</ContentHighlight>: Control access to actions or resources based on user credentials or other criteria.</li>
            <li><ContentHighlight>Resource Filters</ContentHighlight>: Execute before and after model binding and action execution. They are useful for performing tasks like logging or caching.</li>
            <li><ContentHighlight>Exception Filters</ContentHighlight>: Handle exceptions thrown during the execution of an action and provide custom error handling logic.</li>
            <li><ContentHighlight>Result Filters</ContentHighlight>: Operate on the result generated by an action before it's sent back to the client.</li>
        </ul>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="unit-testing-action-filter" class="[ font-semibold text-lg ]">Unit Testing Action Filter</h3>

        <p>
             It would lead us too far to get into all the details on the different types of filters and when exactly they run. Instead, we're going to choose one type of filter, 
             an action filter. Those run immediately before and after an action method is called. They can change the arguments passed into an action, and they can change the 
             result returned from an action. Other filter types can be tested in a likewise manner as <ContentHighlight>action filters</ContentHighlight>, so what you will 
             learn in the upcoming demo can be applied to those other types of filters as well. Important is to know how to mock the dependencies. Let's check that out with a demo.
        </p>

        <GithubGistSnippet Title="WebAPI Action Filter" UserId="fingers10" FileName="f03c9ae6d2c55a95213b593e80ba946b"></GithubGistSnippet>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <p>
            From the above code we can see that we have a simple <ContentHighlight>ActionFilter</ContentHighlight> named <ContentHighlight>ValidateUserRole</ContentHighlight> 
            used to return <ContentHighlight>BadRequestResult</ContentHighlight> if <ContentHighlight>Invoked</ContentHighlight> with <ContentHighlight>User</ContentHighlight> 
            not having <ContentHighlight>master role Claim</ContentHighlight>.
        </p>

        <p>
            Now let's add test to this filter. The steps are,
        </p>

        <ol class="[ list-decimal ] [ ml-4 ]">
            <li>In <ContentHighlight>Arrange</ContentHighlight>, the first step is to <ContentHighlight>new()</ContentHighlight> up <ContentHighlight>ValidateUserRole ActionFilter</ContentHighlight></li>
            <li>
                The <ContentHighlight>ActionFilter</ContentHighlight> needs <ContentHighlight>ActionExecutingContext</ContentHighlight>. To create that we need <ContentHighlight>ActionContext</ContentHighlight> 
                which in turn depend on <ContentHighlight>HttpContext</ContentHighlight>. We need to properly mock / create them.
            </li>
            <li>For <ContentHighlight>HttpContext</ContentHighlight>, we can simply use the <ContentHighlight>DefaultHttpContext</ContentHighlight>.</li>
            <li>
                We can use the above created <ContentHighlight>HttpContext</ContentHighlight> and use it as a first parameter to create <ContentHighlight>ActionContext</ContentHighlight> 
                and simply pass <ContentHighlight>new()</ContentHighlight> to rest of parameters.
            </li>
            <li>
                Now we can create <ContentHighlight>ActionExecutingContext</ContentHighlight> by passing the <ContentHighlight>ActionContext</ContentHighlight>, an empty list of 
                <ContentHighlight>FilterMetadata</ContentHighlight>, an empty <ContentHighlight>dictionary</ContentHighlight>, and a <ContentHighlight>null controller</ContentHighlight> 
                instance.
            </li>
            <li>
                The <ContentHighlight>Act</ContentHighlight> step involves executing the <ContentHighlight>OnActionExecuting</ContentHighlight> method of the filter, passing the 
                previously arranged <ContentHighlight>ActionExecutingContext</ContentHighlight> as the parameter.
            </li>
            <li>
                Finally in the <ContentHighlight>Assert</ContentHighlight> step, we verify the expected behavior of the action filter. In our example, we assert that the result 
                returned by the <ContentHighlight>ActionExecutingContext</ContentHighlight> is of type <ContentHighlight>BadRequestResult</ContentHighlight>, indicating that a bad 
                request should be returned.
            </li>
            <li>
                You can perform this assertion by checking the type of the result as 
                <ContentHighlight CssClasses="[ break-all ]">Assert.IsType&lt;BadRequestResult&gt;(actionExecutingContext.Result);</ContentHighlight>
            </li>
        </ol>

        <GithubGistSnippet Title="WebAPI Action Filter Test" UserId="fingers10" FileName="a2941fbcf64daf901a2648988c2163a2"></GithubGistSnippet>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="summary" class="[ font-semibold text-lg ]">Summary</h3>

        <p>
            Unit testing ASP.NET Core filters is crucial to ensure the correctness and reliability of custom behaviors implemented in your application. By performing unit 
            tests on filters, you can catch bugs early, improve code quality, and gain confidence in making code changes and enhancements.
        </p>

        <p>
            In this article, we focused on unit testing an <ContentHighlight>action filter</ContentHighlight> in ASP.NET Core. We explored the importance of unit testing and 
            discussed the different types of filters available. Using the example of the <ContentHighlight>ValidateUserRole</ContentHighlight> filter, we walked through the 
            steps of <ContentHighlight>arranging</ContentHighlight>, <ContentHighlight>acting</ContentHighlight>, and <ContentHighlight>asserting</ContentHighlight> to 
            effectively test the filter's behavior.
        </p>

        <p>
            Remember, unit testing is an ongoing process that should be integrated into your development workflow. By investing time in creating comprehensive unit tests, 
            you can build robust and maintainable ASP.NET Core applications that provide reliable and expected results.
        </p>

        <p>
            Keep exploring the various types of filters and their testing approaches to enhance your understanding and proficiency in ASP.NET Core development. Happy coding 
            and testing!
        </p>
    </ContentBody>
</Content>

@code {
    private string Description = "In this post I will teach how to unit test filters in ASP.NET web api. All with live working demo.";
    private string Slug = "unit-testing-filters-in-asp-net-webapi";
    private string PosterPath = "Blogs/WebAPI";
    private string Channel = "webapi";
    private string ContentType = "blogs";
    private ushort TotalContents => (ushort)tableOfContents.Contents.Count(content => content.Type.Equals("WebAPI", StringComparison.CurrentCultureIgnoreCase));
}