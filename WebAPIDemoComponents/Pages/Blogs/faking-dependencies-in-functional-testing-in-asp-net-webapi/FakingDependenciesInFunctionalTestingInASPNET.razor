@page "/blogs/faking-dependencies-in-functional-testing-in-asp-net-webapi"
@inherits BasePage

<Content FileName=@nameof(FakingDependenciesInFunctionalTestingInASPNET) UseNewTableOfContentsMenu=true>
    <ContentBody>
        <What>
            <p>
                In this article, let's learn about how to fake dependencies in <ContentHighlight>Functional Test</ContentHighlight> in 
                <ContentHighlight>WebAPI</ContentHighlight> in ASP.NET Core.
            </p>

            <p>
                <strong>Note:</strong> If you have not done so already, I recommend you read the article on
                <NavLink href="blogs/functional-testing-your-asp-net-webapi" Match="NavLinkMatch.All">Functional testing your ASP.NET WEB API</NavLink>.
            </p>

            <p>
                There are situations where we need to <ContentHighlight>fake dependencies or replace services</ContentHighlight> in our Functional Test. We'll learn 
                about where to place the <ContentHighlight>boundary</ContentHighlight> for integration tests and how this relates to the <ContentHighlight>external 
                dependencies, such as a database, queues, etc</ContentHighlight>. And we'll create a fake for a dependency at that defined boundary.
            </p>
        </What>

        <Why>
            <p>
                Rather than using services from our <ContentHighlight>real cloud provider</ContentHighlight> in this article, which would complicate the setup to 
                follow along, it's good enough to use our imagination. When working with cloud providers, it's common to use language-specific SDKs that they supply 
                and maintain to code against their managed services. The implementations just hold the data in memory to mimic a real service, and that's sufficient 
                for this scenario.
            </p>

            <p>
                The benefits of faking in functional tests include:
            </p>

            <ul>
                <li>Savings in <ContentHighlight>cost</ContentHighlight>.</li>
                <li>Faster <ContentHighlight>time</ContentHighlight> to complete the test.</li>
                <li><ContentHighlight>Simple & Easy</ContentHighlight> to setup.</li>
            </ul>

            <p>
                Therefore, lets fake these kind of dependencies.
            </p>
        </Why>

        <How>
            <p>
                Let's begin by creating a new test method named <ContentHighlight CssClasses="[ break-all ]">GetWeatherForecastFromDatabase</ContentHighlight>, and 
                we'll copy previous test to send the request and deserialize the response. So at this point, running the test results in a <ContentHighlight>failure</ContentHighlight>. 
                Before we complete this test and its implementation, let's review the architecture of the API. We're building a cloud-native web API, so let's 
                imagine that we're going to use some cloud services such as a managed database.
            </p>

            <CodeSnippet CssClass="language-csharp">
using API;
using FluentAssertions;
using System.Diagnostics.CodeAnalysis;
using System.Net;
using Xunit.Abstractions;

namespace FunctionalTest;
[ExcludeFromCodeCoverage]
public class WeatherForecastControllerShouldTests(
    CustomWebApiFactory factory,
    ITestOutputHelper outputHelper) : BaseTest(factory), IClassFixture&lt;CustomWebApiFactory&gt;
{
    [Fact]
    public async Task ReturnExpectedResponse_From_Database()
    {
        var result = await Client.GetJsonResultAsync&lt;List&lt;WeatherForecast&gt;&gt;("/weatherforecast/fromdatabase", HttpStatusCode.OK, outputHelper);
        result.Count.Should().Be(1);
        result[0].Summary.Should().Be("Freezing from database");
    }
}
            </CodeSnippet>

            <figure>
                <img src="./image/blogs/webapi/faking-dependencies-in-functional-testing-in-asp-net-webapi/failing-test.png" alt="failing-test" class="[ w-full ]" />
            </figure>

            <p>
                We have <ContentHighlight CssClasses="[ break-all ]">WeatherForecastDbContext</ContentHighlight> class in our API project. This is configured with 
                cloud connection string and registed in <ContentHighlight>Program.cs</ContentHighlight>. We are going to inject this into our action method and read 
                the weather forecast data from database. I'm going to get into details of setting up <ContentHighlight>DbContext</ContentHighlight>. I'll cover this 
                in my <ContentHighlight>EntityFramework</ContentHighlight> Learning Path.
            </p>

            <figure>
                <caption>Endpoint to return values from Database</caption>
                <img src="./image/blogs/webapi/faking-dependencies-in-functional-testing-in-asp-net-webapi/from-database-endpoint.png" alt="from-database-endpoint" class="[ w-full ]" />
            </figure>

            <figure>
                <caption>Swagger output from Endpoint to return values from Database</caption>
                <img src="./image/blogs/webapi/faking-dependencies-in-functional-testing-in-asp-net-webapi/swagger-response.png" alt="swagger-response" class="[ w-full ]" />
            </figure>

            <h4>Faking Database</h4>

            <p>
                In this example in our API, we are going to use <ContentHighlight>EntityFramework</ContentHighlight> to connect to cloud database. We can fake the 
                database by using an <ContentHighlight>in-memory sqlite</ContentHighlight> database provider to run our tests. Reason to use in memory sqlite 
                provider than in memory database is to make sure relation constraints are working as expected.
            </p>

            <ol>
                <li>
                    <p>
                        Add reference to <ContentHighlight CssClasses="[ break-all ]">Microsoft.EntityFrameworkCore.Sqlite</ContentHighlight> and 
                        <ContentHighlight CssClasses="[ break-all ]">Microsoft.Data.Sqlite</ContentHighlight> Nuget Package in 
                        <ContentHighlight CssClasses="[ break-all ]">FunctionalTest.csproj</ContentHighlight>.
                    </p>
                </li>
                <li>
                    <p>
                        Add <ContentHighlight>static DatabaseHelper.cs</ContentHighlight> helper class to <ContentHighlight>Initialize</ContentHighlight> and 
                        <ContentHighlight>Reset</ContentHighlight> Data for used in tests.
                    </p>

                    <CodeSnippet CssClass="language-csharp">
using API;
using API.DbContexts;

namespace FunctionalTest;

public static class DatabaseHelper
{
    public static async Task InitializeDbForTestsAsync(WeatherForecastDbContext db)
    {
        await db.WeatherForecasts.AddAsync(
            new WeatherForecast
            {
                Id = 1,
                Date = DateOnly.FromDateTime(DateTime.Now.AddDays(1)),
                TemperatureC = 1,
                Summary = "Freezing from database"
            });
        await db.SaveChangesAsync();
    }

    public static async Task ResetDbForTestsAsync(WeatherForecastDbContext db)
    {
        db.WeatherForecasts.RemoveRange(db.WeatherForecasts);
        await db.SaveChangesAsync();
    }
}
                    </CodeSnippet>
                </li>
                <li>
                    <p>
                        Now we need to setup <ContentHighlight>IAsyncLifetime</ContentHighlight> using <ContentHighlight>SharedFixture</ContentHighlight> to 
                        <ContentHighlight>Initialize</ContentHighlight> <strong>database only once for all tests</strong>. This is shown in the below code.
                    </p>

                    <CodeSnippet CssClass="language-csharp">
using API.DbContexts;
using Microsoft.Data.Sqlite;
using Microsoft.EntityFrameworkCore;

namespace FunctionalTest;
public class SharedFixture : IAsyncLifetime
{
    public const string DatabaseName = "InMemoryTestDb";
    public WeatherForecastDbContext DbContext = default!;

    public async Task InitializeAsync()
    {
        // Sqlite
        var connectionStringBuilder = new SqliteConnectionStringBuilder
        {
            DataSource = DatabaseName,
            Mode = SqliteOpenMode.Memory,
            Cache = SqliteCacheMode.Shared
        };
        var connection = new SqliteConnection(connectionStringBuilder.ToString());

        var dbContextOptions = new DbContextOptionsBuilder&lt;WeatherForecastDbContext&gt;()
            .UseSqlite(connection)
            .Options;

        DbContext = new WeatherForecastDbContext(dbContextOptions);

        try
        {
            await DbContext.Database.EnsureDeletedAsync();
            await DbContext.Database.OpenConnectionAsync();
            await DbContext.Database.EnsureCreatedAsync();
            await DatabaseHelper.ResetDbForTestsAsync(DbContext);
            await DatabaseHelper.InitializeDbForTestsAsync(DbContext);
        }
        catch (Exception)
        {
            throw;
        }
    }

    public async Task DisposeAsync()
    {
        if (DbContext is not null)
        {
            await DbContext.DisposeAsync();
        }
    }
}
                    </CodeSnippet>
                </li>
                <li>
                    <p>
                        Next we need to setup <ContentHighlight>CollectionDefinition</ContentHighlight> using 
                        <ContentHighlight>ICollectionFixture&lt;TFixture&gt;</ContentHighlight> to make sure our fixture is initialized only once just before 
                        running first test in collection. This is shown in the below code.
                    </p>

                    <CodeSnippet CssClass="language-csharp">
namespace FunctionalTest;

[CollectionDefinition(nameof(FunctionalTestCollection))]
public class FunctionalTestCollection : ICollectionFixture&lt;SharedFixture&gt;
{
    // This class has no code, and is never created. Its purpose is simply to be the place
    // to apply [CollectionDefinition] and all the ICollectionFixture&lt;&gt; interfaces.
}
                    </CodeSnippet>
                </li>
                <li>
                    <p>
                        Finally we need to configure in memory sqlite db in <ContentHighlight>ConfigureServices</ContentHighlight> inside 
                        <ContentHighlight>ConfigureWebHost</ContentHighlight> to <ContentHighlight>override</ContentHighlight> the <ContentHighlight>Service 
                        Registration</ContentHighlight> in <ContentHighlight>CustomWebApiFactory</ContentHighlight> from <ContentHighlight>Program.cs</ContentHighlight>. 
                    </p>

                    <p>
                        We need to find <ContentHighlight>WeatherForecastDbContext</ContentHighlight> and <ContentHighlight>remove</ContentHighlight> and then 
                        <ContentHighlight>create a sqlite in-memory connection and re-register WeatherForecastDbContext</ContentHighlight> with the sqlite in-memory 
                        connection. We can inject <ContentHighlight>SharedFixture</ContentHighlight> to get Sqlite in memory database connection string. This is 
                        shown in the below code.
                    </p>

                    <CodeSnippet CssClass="language-csharp">
using API.DbContexts;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Mvc.Testing;
using Microsoft.Data.Sqlite;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;

namespace FunctionalTest;
public class CustomWebApiFactory(SharedFixture fixture) : WebApplicationFactory&lt;Program&gt;
{
    public SharedFixture SharedFixture =&gt; fixture;

    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        builder.UseEnvironment("Test");

        builder.ConfigureServices(services =&gt;
        {
            var ctx = services.SingleOrDefault(d =&gt; d.ServiceType == typeof(WeatherForecastDbContext));
            services.Remove(ctx!);

            var connectionStringBuilder = new SqliteConnectionStringBuilder
            {
                DataSource = SharedFixture.DatabaseName,
                Mode = SqliteOpenMode.Memory,
                Cache = SqliteCacheMode.Shared
            };
            var connection = new SqliteConnection(connectionStringBuilder.ToString());

            // SQLite
            services.AddDbContext&lt;WeatherForecastDbContext&gt;(opts =&gt;
                opts.UseSqlite(connectionStringBuilder.ToString()));
        });
    }
}
                    </CodeSnippet>
                </li>
            </ol>            <p>
                Thats it. We are done with setup. Now the tests will run in the following flow.
            </p>

            <ol>
                <li>Start Test Method.</li>
                <li>Create WebApplicationFactory.</li>
                <li>Run Program.cs.</li>
                <li>Service Registration.</li>
                <li>Overriding Service Registration with ConfigureServices.</li>
                <li>Build Web Application.</li>
                <li>Create HTTP Client.</li>
                <li>Test Code Execution.</li>
            </ol>

            <p>
                Before we run the test, we need to modify <ContentHighlight>BastTest</ContentHighlight> to expose <ContentHighlight>DatabaseContext</ContentHighlight> 
                to test methods to assert values from Database with API result. This is shown in the below code.
            </p>

            <CodeSnippet CssClass="language-csharp">
using API.DbContexts;

namespace FunctionalTest;

public abstract class BaseTest(CustomWebApiFactory factory)
{
    protected CustomWebApiFactory Factory =&gt; factory;
    protected HttpClient Client =&gt; factory.CreateClient();
    protected WeatherForecastDbContext Database =&gt; factory.SharedFixture.DbContext;
}
            </CodeSnippet>

            <p>
                Now we need to decorate the test class with <ContentHighlight CssClasses="[ break-all ]">[Collection(nameof(FunctionalTestCollection))]</ContentHighlight> 
                and modify the test as shown below to get values from database and assert it with API result as shown below. Lets run the test and see the result.
            </p>

            <CodeSnippet CssClass="language-csharp">
using API;
using FluentAssertions;
using Microsoft.EntityFrameworkCore;
using System.Diagnostics.CodeAnalysis;
using System.Net;
using Xunit.Abstractions;

namespace FunctionalTest;
[ExcludeFromCodeCoverage]
[Collection(nameof(FunctionalTestCollection))]
public class WeatherForecastControllerShouldTests(
    CustomWebApiFactory factory,
    ITestOutputHelper outputHelper) : BaseTest(factory), IClassFixture&lt;CustomWebApiFactory&gt;
{
    [Fact]
    public async Task ReturnExpectedResponse_From_Database()
    {
        var expectedWeatherForecast = await Database.WeatherForecasts.FirstAsync();

        var result = await Client.GetJsonResultAsync&lt;List&lt;WeatherForecast&gt;&gt;("/weatherforecast/fromdatabase", HttpStatusCode.OK, outputHelper);
        result.Count.Should().Be(1);
        result[0].Should().BeEquivalentTo(expectedWeatherForecast);
    }
}
            </CodeSnippet>

            <figure>
                <img src="./image/blogs/webapi/faking-dependencies-in-functional-testing-in-asp-net-webapi/passing-test.png" alt="passing-test" class="[ w-full ]" />
            </figure>

            <h4>Replacing Services</h4>

            <p>
                Now that we learnt how to fake database. We can also apply the same technique to <ContentHighlight>replace services</ContentHighlight> in our 
                <ContentHighlight>Functional Test</ContentHighlight>. Let's say we have a <ContentHighlight>ExternalAPIService</ContentHighlight> service in our API which 
                implements <ContentHighlight>IExternalAPIService</ContentHighlight>. We can replace this service with a 
                <ContentHighlight>FakeExternalAPIService</ContentHighlight> service in our <ContentHighlight>Functional Test</ContentHighlight>.
            </p>

            <p>
                All we need to do is to find the <ContentHighlight>ExternalAPIService</ContentHighlight> and <ContentHighlight>remove</ContentHighlight> and then 
                <ContentHighlight>create a FakeExternalAPIService</ContentHighlight> with expected output from that service and re-register 
                <ContentHighlight>ExternalAPIService</ContentHighlight> with <ContentHighlight>FakeExternalAPIService</ContentHighlight>. 
                This is shown in the below code.
            </p>

            <p>
                But this way of replacing database or services will be difficult to maintain as we need to write a lot of code as replacement service for each scenario and test 
                all scenarios. So I'll teach you another better way in next article.
            </p>
        </How>

        <Summary>
            <p>
                In this article, we learnt about how to fake dependencies in <ContentHighlight>Functional Test</ContentHighlight> in 
                <ContentHighlight>WebAPI</ContentHighlight> in ASP.NET Core. We learnt about where to place the <ContentHighlight>boundary</ContentHighlight> for 
                integration tests and how this relates to the <ContentHighlight>external dependencies, such as a database, queues, etc</ContentHighlight>. This idea 
                can be extended and applied to any cloud based dependencies. In our next article, we'll learn about how to use <ContentHighlight>TestContainers</ContentHighlight> 
                in <ContentHighlight>Functional Test</ContentHighlight> in <ContentHighlight>WebAPI</ContentHighlight> in ASP.NET Core.
            </p>
        </Summary>
    </ContentBody>
</Content>