@page "/blogs/blazor-wasm-virtualization"
@using BlazorDemoComponents
@inherits FragmentNavigationBase
@inject TableOfContents tableOfContents

<Content Title=@Title
         Description=@Description
         CreatedOn=@CreatedOn
         ModifiedOn=@ModifiedOn
         Slug=@Slug
         PosterPath=@PosterPath
         Keywords=@Keywords
         Channel="@Channel"
         ContentType="@ContentType"
         TotalContents=@TotalContents>
    <ContentBody>
        <p>
            In this article, let's learn about virtualization and how to use virtualization component to load huge data in Blazor WASM application.
        </p>

        <h3 class="[ font-semibold text-lg ]">Table of Contents</h3>
        
        <ol class="[ list-decimal ] [ ml-4 ]">
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#why-virtualization")" Match="NavLinkMatch.All">
                    Why Virtualization?
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#when-virtualization")" Match="NavLinkMatch.All">
                    When Virtualization?
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#without-virtualization")" Match="NavLinkMatch.All">
                    Without Virtualization
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#with-virtualization")" Match="NavLinkMatch.All">
                    With Virtualization
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#virtualize-component")" Match="NavLinkMatch.All">
                    Virtualize Component
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#item-provider-delegate")" Match="NavLinkMatch.All">
                    Item provider delegate
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#placeholder")" Match="NavLinkMatch.All">
                    Placeholder
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#item-size")" Match="NavLinkMatch.All">
                    Item Size
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#overscan-count")" Match="NavLinkMatch.All">
                    Overscan count
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#statechanges")" Match="NavLinkMatch.All">
                    Statechanges
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#summary")" Match="NavLinkMatch.All">
                    Summary
                </NavLink>
            </li>
        </ol>

        <h3 id="why-virtualization" class="[ font-semibold text-lg ]">Why Virtualization?</h3>

        <p>
            Loading a large dataset or displaying data in a grid is a more common way to list data in many applications. Virtualization is a technique for 
            limiting UI rendering to just the parts that are currently visible in UI. This will improve the rendering performance and gives better user 
            experience. For example, virtualization is helpful when the app must render a long list of items and only a subset of items is required to be 
            visible at any given time.
        </p>

        <h3 id="when-virtualization" class="[ font-semibold text-lg ]">When Virtualization?</h3>

        <p>
            Use the Virtualize component when:
        </p>

        <ul class="[ list-disc ] [ ml-4 ]">
            <li>Rendering a set of data items in a loop. For example, loading Recommended Content in I ❤️ .NET</li>
            <li>Most of the items aren't visible due to scrolling.</li>
            <li>The rendered items are the same size.</li>
        </ul>

        <p>
            When the user scrolls to a certain point in the Virtualize component's list of items, the component calculates the visible items to show. 
            Unseen items aren't rendered.
        </p>

        <h3 id="without-virtualization" class="[ font-semibold text-lg ]">Without Virtualization</h3>
        
        <p>
            Without virtualization, a typical list data might use a C# foreach loop to render each item in a list. In the following example:
        </p>

        <ul class="[ list-disc ] [ ml-4 ]">
            <li>tableOfContents.Contents is a collection of contents.</li>
            <li>The VirtualizationContent displays details about each content.</li>
            <li>The @@key directive attribute preserves the relationship of each VirtualizationContent component to its rendered content by the content's ContentId.</li>
        </ul>
        
        @*Code Snippet*@
        
        <DemoSnippet Title="Without Virtualization Demo">
            <p class="[ text-black ] [ dark:text-white ]">
                To demonstrate how list renders without virtualization, let's create a list of contents using foreach loop.
            </p>
            <br />
            <div>
                <VirtualizationDemo EnableVirtualization="false"></VirtualizationDemo>
            </div>
        </DemoSnippet>

        <h3 id="with-virtualization" class="[ font-semibold text-lg ]">With Virtualization</h3>

        <p>
            If the collection contains thousands of contents, rendering the contents takes a long time and users experience a noticeable UI lag. Most of the 
            contents aren't seen because they fall outside of the height of the &lt;div&gt; element.
        </p>

        <p>
            Instead of rendering the entire list of contents at once, replace the foreach loop in the preceding example with the Virtualize component:
        </p>

        <ul class="[ list-disc ] [ ml-4 ]">
            <li>Specify tableOfContents.Contents as a fixed item source to Virtualize&lt;TItem&gt;.Items. Only the currently visible contents are rendered by the Virtualize component.</li>
            <li>Specify a context for each content with the Context parameter. In the following example, content is used as the context, which provides access to each content's details.</li>
        </ul>
        
        @*Code Snippet*@

        <DemoSnippet Title="With Virtualization Demo">
            <p class="[ text-black ] [ dark:text-white ]">
                To demonstrate how list renders with virtualization, let's create a list of contents using Virtualize Component.
            </p>
            <br />
            <div>
                <VirtualizationDemo EnableVirtualization="true"></VirtualizationDemo>
            </div>
        </DemoSnippet>

        <p>
            If a context isn't specified with the Context parameter, use the value of context in the item content template to access each contents's details:
        </p>

        <h3 id="virtualize-component" class="[ font-semibold text-lg ]">Virtualize Component</h3>

        <ul>
            <li>Calculates the number of items to render based on the height of the container and the size of the rendered items.</li>
            <li>Recalculates and rerenders the items as the user scrolls.</li>
            <li>Only fetches the slice of records from an external API that correspond to the current visible region, instead of downloading all of the data from the collection.</li>
        </ul>

        <p>
            The item content for the Virtualize component can include:
        </p>

        <ul class="[ list-disc ] [ ml-4 ]">
            <li>Plain HTML and Razor code, as the preceding example shows.</li>
            <li>One or more Razor components.</li>
            <li>A mix of HTML/Razor and Razor components.</li>
        </ul>

        <h3 id="item-provider-delegate" class="[ font-semibold text-lg ]">Item provider delegate</h3>

        <p>
            If you don't want to load all of the items into memory, you can specify an items provider delegate method to the component's 
            Virtualize&lt;TItem&gt;.ItemsProvider parameter that asynchronously retrieves the requested items on demand. In the following example, the 
            LoadContents method provides the items to the Virtualize component:
        </p>

        @*Code snippet*@

        <p>
            The items provider receives an ItemsProviderRequest, which specifies the required number of items starting at a specific start index. The items 
            provider then retrieves the requested items from a database or other service and returns them as an ItemsProviderResult&lt;TItem&gt; along with 
            a count of the total items. The items provider can choose to retrieve the items with each request or cache them so that they're readily available.
        </p>
        
        <p>
            A Virtualize component can only accept one item source from its parameters, so don't attempt to simultaneously use an items provider and assign a 
            collection to Items. If both are assigned, an InvalidOperationException is thrown when the component's parameters are set at runtime.
        </p>

        <h3 id="placeholder" class="[ font-semibold text-lg ]">Placeholder</h3>

        <p>
            Because requesting items from a remote data source might take some time, you have the option to render a placeholder with item content:
        </p>

        <ul class="[ list-disc ] [ ml-4 ]">
            <li>Use a Placeholder (&lt;placeholder&gt;...&lt;/placeholder&gt;) to display content until the item data is available.</li>
            <li>Use Virtualize&lt;TItem&gt;.ItemContent to set the item template for the list.</li>
        </ul>

        <h3 id="item-size" class="[ font-semibold text-lg ]">Item size</h3>

        <p>
            The height of each item in pixels can be set with Virtualize&lt;TItem&gt;.ItemSize (default: 50). By default, the Virtualize component measures 
            the rendering size (height) of individual items after the initial render occurs. Use ItemSize to provide an exact item size in advance to assist 
            with accurate initial render performance and to ensure the correct scroll position for page reloads. If the default ItemSize causes some items to 
            render outside of the currently visible view, a second re-render is triggered. To correctly maintain the browser's scroll position in a virtualized 
            list, the initial render must be correct. If not, users might view the wrong items. The following example changes the height of each item from the 
            default of 50 pixels to 25 pixels:
        </p>

        @*Code snippet*@

        <h3 id="overscan-count" class="[ font-semibold text-lg ]">Overscan count</h3>
        
        <p>
            Virtualize&lt;TItem&gt;.OverscanCount determines and controls how many additional items are rendered before and after the visible region. 
            This setting helps to reduce the frequency of rendering during scrolling. However, higher values result in more elements rendered in the 
            page (default: 3). The following example changes the overscan count from the default of three items to four items:
        </p>

        @*Code snippet*@

        <h3 id="statechanges" class="[ font-semibold text-lg ]">Statechanges</h3>

        <p>
            When making changes to items rendered by the Virtualize component, call StateHasChanged to force re-evaluation and rerendering of the component.
        </p>
        
        <h3 id="summary" class="[ font-semibold text-lg ]">Summary</h3>

        <p>
            In this article, we learn't how to use virtualization to load huge data without compromising on performance and user experience.
        </p>
    </ContentBody>
</Content>

@code {
    private string Title = "Blazor WASM Virtualization";
    private string Description = "In this post I will teach how to use virtualization in your Blazor applications. All with live working demo.";
    private DateTime CreatedOn = new DateTime(2022, 6, 12, 22, 30, 0);
    private DateTime ModifiedOn = new DateTime(2022, 6, 12, 22, 30, 0);
    private string Slug = "blazor-wasm-virtualization";
    private string PosterPath = "blogs/blazor/wasm";
    private string Channel = "blazor";
    private string ContentType = "blogs";
    private ushort TotalContents => (ushort)tableOfContents.Contents.Count(content => content.Type.Equals("Blazor", StringComparison.CurrentCultureIgnoreCase));
    private List<string> Keywords = new(3) { "Virtualization", "Virtual DOM", "Performance" };
}