@page "/blogs/single-responsibility-principle-in-solid"
@inherits FragmentNavigationBase
@inject TableOfContents tableOfContents

<Content Title=@Title
         Description=@Description
         CreatedOn=@CreatedOn
         ModifiedOn=@ModifiedOn
         Slug=@Slug
         PosterPath=@PosterPath
         Keywords=@Keywords
         Channel="@Channel"
         ContentType="@ContentType"
         TotalContents=@TotalContents
         FileName=@nameof(SingleResponsibility)>
    <ContentBody>
        <p>
            In this article, let's learn about <ContentHighlight>Single Responsibility Principle</ContentHighlight> in <ContentHighlight>SOLID</ContentHighlight> Principles 
            in .NET.
        </p>

        <p>
            <strong>Note:</strong> If you have not done so already, I recommend you read the article on
            <NavLink class="[ underline ]" href="blogs/solid-principles-introduction" Match="NavLinkMatch.All">SOLID Principles Introduction</NavLink>.
        </p>

        <h3 class="[ font-semibold text-lg ]">Table of Contents</h3>
        
        <ol class="[ list-decimal ] [ ml-4 ]">
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#introduction")" Match="NavLinkMatch.All">
                    Introduction
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#when-to-apply-srp")" Match="NavLinkMatch.All">
                    When to apply SRP?
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#demo")" Match="NavLinkMatch.All">
                    Demo
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#advantages")" Match="NavLinkMatch.All">
                    Advantages
                </NavLink>
            </li>
            <li>
                <NavLink class="[ underline ]" href="@($"blogs/{Slug}#summary")" Match="NavLinkMatch.All">
                    Summary
                </NavLink>
            </li>
        </ol>

        <h3 id="introduction" class="[ font-semibold text-lg ]">Introduction</h3>
        
        <p>
            The <ContentHighlight>Single Responsibility Principle (SRP)</ContentHighlight> is a fundamental principle of <ContentHighlight>SOLID</ContentHighlight>. The 
            <ContentHighlight>SRP</ContentHighlight> states that a <ContentHighlight>class</ContentHighlight> should have <ContentHighlight>only one responsibility or one 
            specific functionality</ContentHighlight>. The reason behind this principle is to make the code more modular, maintainable, and reusable. When a 
            <ContentHighlight>class</ContentHighlight> has multiple responsibilities, it becomes difficult to modify or test the code. If a 
            <ContentHighlight>class</ContentHighlight> has many responsibilities, it's time to split into smaller ones. Breaking down the code into smaller, focused classes 
            makes it easier to understand and maintain. This principle applies not only to classes but also to components and microservices.
        </p>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="when-to-apply-srp" class="[ font-semibold text-lg ]">When to apply SRP?</h3>

        <p>
            When you're coding, always ask yourself what the responsibility of the class is, and if it has multiple responsibilities with 
            <ContentHighlight><strong>AND</strong></ContentHighlight>, consider breaking it up into smaller ones.
        </p>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="demo" class="[ font-semibold text-lg ]">Demo</h3>

        <p>
            Let's take an example of a <ContentHighlight>Circle</ContentHighlight> <ContentHighlight>class</ContentHighlight> to understand the Single Responsibility Principle. 
            Suppose we have a <ContentHighlight>Circle class</ContentHighlight> that has two functions, <ContentHighlight>CalculateArea</ContentHighlight> and 
            <ContentHighlight>CalculateCircumference</ContentHighlight> which are used to calculate the <ContentHighlight>area</ContentHighlight> and 
            <ContentHighlight>circumference</ContentHighlight> of the circle. But, if we look a little closer, there's another function called 
            <ContentHighlight>PlotCircleOnCanvas</ContentHighlight>. Doing something on a <ContentHighlight>canvas</ContentHighlight> is a different responsibility and is not 
            directly related to the <ContentHighlight>circle</ContentHighlight>. In essence, this function does not belong to this class.
        </p>

        <GithubGistSnippet Title="SRP - Single Responsibility Principle - Before" UserId="fingers10" FileName="dd0cd1f9e36f528d2bb5c36bffec5000"></GithubGistSnippet>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <p>
            To apply the Single Responsibility Principle, we will create a new class called <ContentHighlight>PlotOnCanvas</ContentHighlight> to contain the functionality of 
            plotting on a canvas. We will cut the <ContentHighlight>PlotCircleOnCanvas</ContentHighlight> function from the <ContentHighlight>Circle class</ContentHighlight> and 
            paste it into the <ContentHighlight>PlotOnCanvas class</ContentHighlight>. Now we will rename to <ContentHighlight>PlotCircle</ContentHighlight> to indicate that 
            it's plotting a circle. We can also add another method <ContentHighlight>PlotSquare</ContentHighlight> to plot a square.
        </p>

        <GithubGistSnippet Title="SRP - Single Responsibility Principle - After" UserId="fingers10" FileName="d9734828d8fb60ba742e61b01e34a6b6"></GithubGistSnippet>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="advantages" class="[ font-semibold text-lg ]">Advantages</h3>

        <p>
            The Single Responsibility Principle has several advantages, including:
        </p>

        <ul>
            <li><ContentHighlight>Modularity</ContentHighlight>: Breaking down code into smaller, focused classes makes it more modular and easier to understand.</li>
            <li><ContentHighlight>Maintainability</ContentHighlight>: When a class has only one responsibility, it's easier to modify or test the code without affecting other parts of the system.</li>
            <li><ContentHighlight>Reusability</ContentHighlight>: Smaller classes with specific functionality can be reused in other parts of the system.</li>
            <li><ContentHighlight>Scalability</ContentHighlight>: By keeping classes focused on one specific functionality, it's easier to scale the system without worrying about affecting other parts of the system.</li>
        </ul>

        <GoogleAdSense Type="GoogleAdSenseAdType.InArticle" Format="GoogleAdSenseAdFormat.Fluid" Style="text-align:center;" Slot="3914293965"></GoogleAdSense>

        <h3 id="summary" class="[ font-semibold text-lg ]">Summary</h3>

        <p>
            In this article we learn't what is <ContentHighlight>SOLID</ContentHighlight> principles.In conclusion, the Single Responsibility Principle is an important concept 
            in the SOLID principles of object-oriented programming. It states that every class, module, component, or microservice should have <ContentHighlight>one specific 
            responsibility or functionality</ContentHighlight>. This makes the code more <ContentHighlight>readable, flexible, and maintainable</ContentHighlight>. When you're 
            coding, always ask yourself what the responsibility of the class is, and if it has multiple responsibilities, consider breaking it up into smaller ones.
        </p>

        <p>
            In the C# example provided, we saw how the <ContentHighlight>Circle</ContentHighlight> class had a function that was not directly related to the circle's 
            functionality, and therefore violated the Single Responsibility Principle. We created a new <ContentHighlight>class</ContentHighlight> called 
            <ContentHighlight>PlotOnCanvas</ContentHighlight> to handle the plotting functionality, and moved the relevant function from the Circle class to the new class. 
            This helped us adhere to the Single Responsibility Principle and improved the overall design of our code.
        </p>
    </ContentBody>
</Content>

@code {
    private string Title = "Single Responsibility Principle in SOLID";
    private string Description = "In this post I will teach you Single Responsibility Principle in SOLID Principles in .NET. All with live working demo.";
    private DateTime CreatedOn = new DateTime(2023, 4, 16, 22, 30, 0);
    private DateTime ModifiedOn = new DateTime(2023, 4, 16, 22, 30, 0);
    private string Slug = "single-responsibility-principle-in-solid";
    private string PosterPath = "Blogs/SOLID";
    private string Channel = "solid";
    private string ContentType = "blogs";
    private ushort TotalContents => (ushort)tableOfContents.Contents.Count(content => content.Type.Equals("SOLID", StringComparison.CurrentCultureIgnoreCase));
    private List<string> Keywords = new(2) { "SRP", "Single Responsibility" };
}